事务
	数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。
	隔离性：
		指当多个用户并发操作数据库时，数据库为每一个用户开启不同的事务，这些事务之间相互不干扰，相互隔离。
		
	不隔离事务会出现哪些问题？
		1、脏写
				事务A和事务B同时在更新一条数据，事务A先把它更新为A值，事务B紧接着就把它更新为B值。
				事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚，导致事务B修改的值也没了。
		2、脏读
				A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。
			解决方法：
				如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可以避免该问题。
			
			<无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据。因为另外一个事务还没提交，
			所以它随时可能会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了，这就是脏写和脏读>
				
		3、不可重复读
				一个事务对同一行数据重复读取两次，但是却得到了不同的结果。事务A读取某一数据后，事务B对其做了修改，当事务A再次读该数据时得
			到与前一次不同的值。 
			解决方法：
				如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。
		4、幻读
			指一个事务执行两次查询，但第二次查询的结果包含了第一次查询中未出现的数据。
			
			
			
四种隔离级别
	-> 读未提交(READ UNCOMMITTED)
			在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。
		读取未提交的数据，也被称之为脏读。
			MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加
		锁、解锁带来的性能开销。
			依然可能发生：<脏读，不可重复读，幻读>
	
	-> 读已提交(READ COMMITED)
			这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
		这种隔离级别也支持所谓的不可重复读（NonrepeatableRead），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一
		select可能返回不同结果。
			依然可能发生：<不可重复读，幻读>

	-> 可重复读(REPEATABLE READ)
			这是MySQL的默认事务隔离级别，同一事务的多个实例在并发读取数据时，会看到同样的数据。不过理论上，这会导致另一个棘手的问题：
		幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数
		据行时，会发现有新的“幻影” 行。
			依然可能发生：<幻读>

	-> 可串行化(SERIALIZABLE)
			这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。
		在这个级别，可能导致大量的超时现象和锁竞争。
	
	
	
	
	
	
	
	
	
	
	