
-> NoSql概述
	背景<mysql演变>
		本质：解决读与写的效率问题。
			单机版MySql中的问题：
					// 数据量太大，单机就放不下
					// 数据的索引，单机内存放不下
					// 访问量(读写混合)，单机承受不住

			衍生出‘memcached(缓存)+mysql+垂直拆分’：
					<服务器垂直拆分<读写分离>，将写入内容同步到其他服务器>
					// 网站大部分情况下都是去访问读取数据，每次都需要与数据库交互查询，影响效率，数据压力较大
			
				解决：在访问中间添加一个缓存，数据缓存之后，提升效率
			
			缓存演变：
					优化数据库结构与索引 ---> 文件缓存(io操作) ---> memcacahed
				
			分库分表+水平拆分+mysql集群
					// 将几个单机组合成一组作战单元，这个作战单元有主从之分，而这个作战单元就是一个节点(小集群)，多个节点组成一个大的项目集群。
						<节点也可以是一个单机，只是这个节点很小而已，每个节点的任务可能不同>
			
	为什么要使用NoSql？
		在应用使用时会出现，用户的个人信息、社交网络、地理位置产生大量用户日志等数据，这种爆发式增长需要使用NoSql数据库。
		同时，由于关系型数据库面对大数据时，其扩展性、高昂的表变更成本、高并发容量、写入延迟等方面有限。
		
	什么是NoSql？
			<not only sql 不仅仅是sql，泛指非关系型数据库>

	NoSql特点：
		// 方便扩展<数据之间没有强关系，很好扩展>
		// 大数据量高性能<Redis一秒8万次，读取11万。NoSql的缓存记录级，是一种细粒度的存储，性能很高>
		// 数据类型是多样型的<不需要事先设计数据库，随取随用>
	
	传统RDBMS<关系型>与NoSql区别；
		关系型：
			结构化组织、sql、数据和关系都存储在单独的表中、数据操纵与定义语言、严格一致性、基础的事务、...
		NoSql：
			不仅仅是数据、没有固定的查询语言、键值对存储，列存储，文档存储，图形数据库、最终一致性、CAP定理和BASE、高性能，高可用，高扩展
	
	大数据时代的 3V+3高：
		3V：<主要是描述问题的>
			海量(Volume)、多样(Variety)<数据类型众多>、实时(Velocity)
		3高：<主要是对程序的要求>
			高并发、高可扩(随时水平拆分)、高性能
	
	
	NoSql四大数据类型分类
		1、key-value键值对
			应用场景：内容缓存，主要用于处理大量的高访问负载，也用于一些日志系统等等。
			优点：查询速度快
			缺点：数据无结构化，通常只被当做字符串或者二进制数据。
				
		2、文档型数据<bson格式(与json一样)>
			数据模型：key-value键值对，value是结构化数据
			举例：
				-> MongoDB
					MongoDB是一个基于分布式文件存储的数据库，C++编写，用来处理大量的文档。
					它是介于关系型数据库和非关系型数据库的中间产品。且是非关系型数据库中功能最丰富的，最像关系型数据库的。
				-> ConthDB
			应用场景：Web应用(与键值对类似，value是结构化的，不同的是数据库能够了解value的内容)
			优点：数据结构要求不严格，表结构可变，不需要像关系型数据库一样预定义表结构。
			缺点：查询性能不高，而且缺乏统一的查询语法。
			
		3、列存储数据库
			数据模型：以列簇式存储，将同一列数据存在一起。
			举例：
				-> HBase
				-> Cassandra
			应用场景：分布式的文件系统
			优点：查询速度快，可扩展性强，更容易进行分布式扩展。
			缺点：功能相对局限
			
		4、图关系数据库
			数据模型：图结构<一种网络图数据结构，就是数学中的图论>
			举例：
				-> Neo4J
				-> InfoGrid
			应用场景：社交网络、推荐系统等，专注于构建关系图谱
			优点：利用图结构相关算法。比如最短路径寻址，N度关系查找等
			缺点：很多时候需要对整个图做计算才能得到需要的信息，而且这种结构不太好做分布式的集群方式

-------------------------------------------
学习中文网：http://www.redis.cn/
下载：官网下载，windows在github上下载，当然也可以将linux版本安装在windows上


-> Redis概述
	<Remote Dictionary Server>，远程字典服务
		是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日执行、key-value数据库，并提供多种语言的API。
	
	Redis作用：
		内存存储<将数据缓存到内存中>;
		持久化：将内存中的数据持久化到磁盘中，内存中的数据是断电即失的(持久化的重要性)<RDB、AOF>。
		效率高，可以用于高速缓存。
		发布订阅系统
		地图信息分析
		计时器、计数器(浏览量)

-> 安装与运行
	windows上：
		安装：
				安装包：https://github.com/dmajkic/redis/releases
			直接解压即可。
		运行：
			开启Redis，双击运行服务<redis-server.exe>即可。
			默认端口：6379
		客户端运行：
			双击<redis-cl.exe>客户端服务。(注意不要关闭服务端)
			测试是否连接到服务端：ping ==> PONG		|		<设置键值对>set name qlj	 |	 <通过key获取value>get name
			
	linux上：
		下载安装包：在官网下载。
		
		
		
		
		运行：
			cd /usr/local/src/redis-6.2.6
			redis-server redis.conf					// 启动
			// 停止服务
			redis-cli -u 123456 shutdown			// 由于配置了密码，所以要通过密码指定密码进行停止
			
			// 开机自启redis服务
				-> 创建一个系统服务文件：vim /etc/systemd/system/redis.service
				-> 写入文件内容：
						[Unit]
						Description=redis-server
						After=network.target
						
						[Service]
						Type=forking
						ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf
						PrivateTmp=true
						
						[Install]
						WantedBy=multi-user.target
				-> 重载系统服务命令：systemctl daemon-reload
				-> 启动redis：systemctl start redis
				-> 查看redis运行状态：systemctl status redis
				-> 停止redis：systemctl stop redis
				-> 重启redis：systemctl restart redis
				-> 开机自启：systemctl enable redis
				
-> redis客户端
	// 命令行客户端
		使用命令行客户端：
			执行命令：redis-cli [option] [commonds]
				[option]：
					-h 127.0.0.1	<指定要连接的redis节点的ip地址，默认是127.0.0.1(本地)>
					-p 6379				<指定要连接的redis节点的端口，默认6379>
					-a 123456			<指定redis访问密码，没有密码可以不指定>
				[commonds]：<redis操作命令，一般不指定>
					ping：与redis服务端做心跳测试，服务端正常就返回pong
					// 不指定commond时，会进入redis-cli的交互平台。
			例：进入命令行客户端
				方式一：
					redis-cli -h 127.0.0.1 -p 6379 -a 123456
					// 测试进入
					ping			// 输出pong,表示正常
				方式二：
					// 依次执行
					redis-cli -h 127.0.0.1 -p 6379
					auth 123456				// 没有用户名时就是直接写密码
					ping
		
	// 图形化桌面客户端
		下载地址：https://github.com/lework/RedisDesktopManager-Windows/releases
			下载rdm-2021.9.zip
		直接win下解压，安装即可。
		rdm.exe文件就是运行文件。
	
	// 编程客户端				
		
	
-> 基础知识
	1、linux总共有16个数据库，从0~15。
		// 如何查看?	<直接vim查看redis的配置文件>
		// 如何切换？	<select 序号。 例：select 2   切换到第三个数据库>
			命令：
				-> dbsize							<查看数据库使用情况>
				-> set name qlj				<向数据库中存储一个键值对(name:qlj)>
				-> get name						<根据键取出对应的值>
				-> key *							<查看所有的key。(必须在存储的数据库中查找)>
				-> flushdb						<清空当前数据库>
				-> flushall						<清空全部数据库内容>
				-> exists name				<判断集合中是否包含'name'这个key是否存在，存在返回1>
				-> move name 1				<移动key为'name'的键值对到指定数据库1中，相当于剪切复制>
				-> expire name 10			<设置10s后，key为name的键值对就会过期，过期后就查询不到了>
					可以使用 ttl name 命令查询过期剩余时间
				-> type name 					<返回key所存储的value值类型>
				-> hlep @generic			<查看所有类型通用的命令，也可以修改@后面的类型，如：help @hash>
				------------
				-> append name " nb"	<对指定key的value后拼接字符串,key值不存在时就创建键值对。例：添加后(name:qlj nb)>
				-> strlen name ""			<通过key获取value字符串长度>

	2、redis是单线程的
		redis是基于内存操作的，CPU并不是redis的性能瓶颈，redis的瓶颈是根据机器的内存以及网络带宽所决定的。
		
		为什么单线程效率却很快？
			-> 首先，现在的CPU一般都是由多个核心组成，每个核心可以认为是一个独立的处理器，它们能够并行的处理任务。
			   所以，如果我们的CPU是多核的，但是程序是单线程的，那么执行程序时，这个线程在某一时刻只能在一个核心上
			   运行，而其他的核心就是空闲的(假设没有其他程序)。所以，为了提高CPU的使用率，我们可以创建多个线程，每
			   个线程处理任务的一部分(每个部分不依赖)，而每个核心执行一个线程，此时CPU的使用率将提高，程序运行速度
			   自然就会提高。
			-> 除此之外，假设我们的程序有A、B、C三个任务要执行，但是由于程序使用的是单线程，这些任务只能轮流执行，
			   A执行完毕后，其他任务再依次执行。如果A任务是一个比较耗时间的任务，此时B与C任务就要等待很长时间才能
			   执行。如果使用多线程，那么每个线程被分配到不同的核心上，可以并行的执行；若核心数量不够，CPU将采用时
			   间片轮转算法，轮流为每个线程分配时间片执行，这样后续任务也可以进行并发执行，无需等待之前的任务完成，
			   任务的响应速度变得更加均匀。
			<理解redis的单线程>
			-> redis中的单线程并不是指redis程序只会有一个线程。而是指redis处理客户端的数据请求，只会使用一个线程去
			   执行。但是实际上redis在执行其他操作时，可能会开启多个进程或线程，比如说持久化，就会fork出一个子进程，
			   然后子进程创建快照，完成持久化操作。
			<redis为什么是单线程>
			-> redis将数据存放在内存中，这就意味着，redis在操作数据时，不需要进行磁盘的IO，磁盘IO是一个比较耗时的操
			   作，所以对于需要磁盘IO的程序，我们就可以使用多线程，在某个线程进行IO操作的时候，CPU切换到当前程序的其
			   他线程执行，以此减少CPU的等待时间。而redis直接操作内存中的数据，所以使用多线程并不能有效的提升效率，
			   相反，使用多线程反而会因为需要进行线程切换人降低效率。
			   (当然在CPU切换线程的时候，有一个上下文切换时间，而这个上下文切换时间是非常耗费时间的)
			-> 除此之外，使用多线程的话，多个线程之间进行同步，保证线程的安全，也需要开销的。尤其是redis数据结构是一
			   些实现较为简单的集合结构，若使用多线程，将会频繁的发生线程冲突，线程的竞争频率较高，反倒会拖慢redis的
			   响应速度。
			<redis如何提高CPU的使用率>
			-> 前面说过，现在的CPU一般都有多个核心，每个核心可以单独执行。redis处理客户端请求使用单线程，那么自然而然，
			   无法将CPU的核心都占用，也就造成了资源的浪费。为了解决这一问题，我们可以在同一个服务器上开启多个redis程
			   序，每个redis程序使用不同的端口，相互独立，以此提高CPU的使用率，而这么多redis程序可以配置成主从节点，共
			   同为一个程序服务，也可以相互独立，服务于多个程序。
			总结：
				总的来说，redis使用单线程的原因就是：多线程并不能有效地提高redis的性能，相反可能还会降低性能，所以自然就
				会使用单线程。
	
	3、数据类型
		redis是一个key-value的数据库，key一般都是String类型，而value的类型较多。
			例如：
				-- 基本类型
				String：hello word
				Hash：{name:"qlj",age:23}
				List：[A -> B -> C -> C]
				Set：{A,B,C}
				SortedSet：{A:1,B:2,C:3}
				-- 特殊类型
				GEO：{A:{120.3,30.5}}
				BitMap：0101101101
				HyperLog：0101101101
			
		-> 常用命令
			// 查看帮助信息
				help del			<查看del指令如何使用>
				help @generic	<查看通用的命令使用方式>
			
			// 查看符合模板的所有key，生产环境下不建议使用这种方式查询
				keys *				<后面可以进行模糊查询，*表示任意字符;?表示单个字符>
					
			// 删除一个或多个指定的key
				del key [key...] 			<后面可以跟多个keyname，返回的是删除的数量>			
			
			// 判断key是否存在
				exists key [key...]				<判断库中是否存在指定的key，存在返回1，可指定多个key>
			
			// 给一个key设置有效时间，有效时间到期就会自动删除
				expire key 时间(秒)				<例：expire name 10		// 可以使用  命令>
			
			// 查询指定key的剩余时间
				ttl key								<-2 表示过期，-1 表示永久有效，正数 表示剩余时间(秒)>
				
		
		
		-> String
			字符串类型，是redis中最简单的存储类型。
			value可以根据字符串的格式，再细分为3类：
				string：普通字符串	<例：a:hello>
				int：整数类型，可以做自增自减	<例：b:12>
				float：浮点类型，可以做自增自减	<例：c:12.1>
			注意：
				不管是哪种类型的String，底层都是字节数组形式存储，只是编码方式不同。字符串类型最大空间不超过512M
				
				-> 常用String命令
					// set：添加或修改已经存在的一个String类型的键值对
						例：set name qlj
					// get：根据key获取String类型的value
						例：get name
					// mset：批量添加多个String类型的键值对
						例：mset a 1 b 2.1 c 3
					// mget：根据多个key获取多个String类型的value
						例：mget a b c
						
					// incr：让一个整型的key自增1
						例：incr a		<2>
					// incrby：让一个整型的key自增并指定步长。
						例：incrby a 2		<3>			|			incrby a -1		<0>
					// incrbyfloat：让一个浮点类型的数字自增并指定步长
						例：incrbyfloat b 0.5			<2.6>
						
					// setnx：添加一个String类型的键值对，前提是这个key不存在，否则不执行
						例：setnx	name zmq			<由于库中存在name:qlj，此时出现相同的key，所以不执行>
					// setex：添加一个String类型的键值对，并且指定有效期
						例：setex name 10 zmq 			// 等同于：set name zmq ex 10
							<注意：expire命令是当键值存在的情况下才指定有效期，而setex命令在创建时进行指定有效期>
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
				
				
				
				
































