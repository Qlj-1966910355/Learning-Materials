
-> NoSql概述
	背景<mysql演变>
		本质：解决读与写的效率问题。
			单机版MySql中的问题：
					// 数据量太大，单机就放不下
					// 数据的索引，单机内存放不下
					// 访问量(读写混合)，单机承受不住

			衍生出‘memcached(缓存)+mysql+垂直拆分’：
					<服务器垂直拆分<读写分离>，将写入内容同步到其他服务器>
					// 网站大部分情况下都是去访问读取数据，每次都需要与数据库交互查询，影响效率，数据压力较大
			
				解决：在访问中间添加一个缓存，数据缓存之后，提升效率
			
			缓存演变：
					优化数据库结构与索引 ---> 文件缓存(io操作) ---> memcacahed
				
			分库分表+水平拆分+mysql集群
					// 将几个单机组合成一组作战单元，这个作战单元有主从之分，而这个作战单元就是一个节点(小集群)，多个节点组成一个大的项目集群。
						<节点也可以是一个单机，只是这个节点很小而已，每个节点的任务可能不同>
			
	为什么要使用NoSql？
		在应用使用时会出现，用户的个人信息、社交网络、地理位置产生大量用户日志等数据，这种爆发式增长需要使用NoSql数据库。
		同时，由于关系型数据库面对大数据时，其扩展性、高昂的表变更成本、高并发容量、写入延迟等方面有限。
		
	什么是NoSql？
			<not only sql 不仅仅是sql，泛指非关系型数据库>

	NoSql特点：
		// 方便扩展<数据之间没有强关系，很好扩展>
		// 大数据量高性能<Redis一秒8万次，读取11万。NoSql的缓存记录级，是一种细粒度的存储，性能很高>
		// 数据类型是多样型的<不需要事先设计数据库，随取随用>
	
	传统RDBMS<关系型>与NoSql区别；
		关系型：
			结构化组织、sql、数据和关系都存储在单独的表中、数据操纵与定义语言、严格一致性、基础的事务、...
		NoSql：
			不仅仅是数据、没有固定的查询语言、键值对存储，列存储，文档存储，图形数据库、最终一致性、CAP定理和BASE、高性能，高可用，高扩展
	
	大数据时代的 3V+3高：
		3V：<主要是描述问题的>
			海量(Volume)、多样(Variety)<数据类型众多>、实时(Velocity)
		3高：<主要是对程序的要求>
			高并发、高可扩(随时水平拆分)、高性能
	
	
	NoSql四大数据类型分类
		1、key-value键值对
			应用场景：内容缓存，主要用于处理大量的高访问负载，也用于一些日志系统等等。
			优点：查询速度快
			缺点：数据无结构化，通常只被当做字符串或者二进制数据。
				
		2、文档型数据<bson格式(与json一样)>
			数据模型：key-value键值对，value是结构化数据
			举例：
				-> MongoDB
					MongoDB是一个基于分布式文件存储的数据库，C++编写，用来处理大量的文档。
					它是介于关系型数据库和非关系型数据库的中间产品。且是非关系型数据库中功能最丰富的，最像关系型数据库的。
				-> ConthDB
			应用场景：Web应用(与键值对类似，value是结构化的，不同的是数据库能够了解value的内容)
			优点：数据结构要求不严格，表结构可变，不需要像关系型数据库一样预定义表结构。
			缺点：查询性能不高，而且缺乏统一的查询语法。
			
		3、列存储数据库
			数据模型：以列簇式存储，将同一列数据存在一起。
			举例：
				-> HBase
				-> Cassandra
			应用场景：分布式的文件系统
			优点：查询速度快，可扩展性强，更容易进行分布式扩展。
			缺点：功能相对局限
			
		4、图关系数据库
			数据模型：图结构<一种网络图数据结构，就是数学中的图论>
			举例：
				-> Neo4J
				-> InfoGrid
			应用场景：社交网络、推荐系统等，专注于构建关系图谱
			优点：利用图结构相关算法。比如最短路径寻址，N度关系查找等
			缺点：很多时候需要对整个图做计算才能得到需要的信息，而且这种结构不太好做分布式的集群方式

-------------------------------------------
学习中文网：http://www.redis.cn/
下载：官网下载，windows在github上下载，当然也可以将linux版本安装在windows上


-> Redis概述
	<Remote Dictionary Server>，远程字典服务
		是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日执行、key-value数据库，并提供多种语言的API。
	
	Redis作用：
		内存存储<将数据缓存到内存中>;
		持久化：将内存中的数据持久化到磁盘中，内存中的数据是断电即失的(持久化的重要性)<RDB、AOF>。
		效率高，可以用于高速缓存。
		发布订阅系统
		地图信息分析
		计时器、计数器(浏览量)

-> 安装与运行
	windows上：
		安装：
				安装包：https://github.com/dmajkic/redis/releases
			直接解压即可。
		运行：
			开启Redis，双击运行服务<redis-server.exe>即可。
			默认端口：6379
		客户端运行：
			双击<redis-cl.exe>客户端服务。(注意不要关闭服务端)
			测试是否连接到服务端：ping ==> PONG		|		<设置键值对>set name qlj	 |	 <通过key获取value>get name
			
	linux上：
		下载安装包：在官网下载。
		
		
		
		
		运行：
			cd /usr/local/src/redis-6.2.6
			redis-server redis.conf					// 启动
			// 停止服务
			redis-cli -u 123456 shutdown			// 由于配置了密码，所以要通过密码指定密码进行停止
			
			// 开机自启redis服务
				-> 创建一个系统服务文件：vim /etc/systemd/system/redis.service
				-> 写入文件内容：
						[Unit]
						Description=redis-server
						After=network.target
						
						[Service]
						Type=forking
						ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf
						PrivateTmp=true
						
						[Install]
						WantedBy=multi-user.target
				-> 重载系统服务命令：systemctl daemon-reload
				-> 启动redis：systemctl start redis
				-> 查看redis运行状态：systemctl status redis
				-> 停止redis：systemctl stop redis
				-> 重启redis：systemctl restart redis
				-> 开机自启：systemctl enable redis
				
-> redis客户端
	// 命令行客户端
		使用命令行客户端：
			执行命令：redis-cli [option] [commonds]
				[option]：
					-h 127.0.0.1	<指定要连接的redis节点的ip地址，默认是127.0.0.1(本地)>
					-p 6379				<指定要连接的redis节点的端口，默认6379>
					-a 123456			<指定redis访问密码，没有密码可以不指定>
				[commonds]：<redis操作命令，一般不指定>
					ping：与redis服务端做心跳测试，服务端正常就返回pong
					// 不指定commond时，会进入redis-cli的交互平台。
			例：进入命令行客户端
				方式一：
					redis-cli -h 127.0.0.1 -p 6379 -a 123456
					// 测试进入
					ping			// 输出pong,表示正常
				方式二：
					// 依次执行
					redis-cli -h 127.0.0.1 -p 6379
					auth 123456				// 没有用户名时就是直接写密码
					ping
		
	// 图形化桌面客户端
		下载地址：https://github.com/lework/RedisDesktopManager-Windows/releases
			下载rdm-2021.9.zip
		直接win下解压，安装即可。
		rdm.exe文件就是运行文件。
	
	// 编程客户端				
		
	
-> 基础知识
	1、linux总共有16个数据库，从0~15。
		// 如何查看?	<直接vim查看redis的配置文件>
		// 如何切换？	<select 序号。 例：select 2   切换到第三个数据库>
			命令：
				-> dbsize							<查看数据库使用情况>
				-> set name qlj				<向数据库中存储一个键值对(name:qlj)>
				-> get name						<根据键取出对应的值>
				-> key *							<查看所有的key。(必须在存储的数据库中查找)>
				-> flushdb						<清空当前数据库>
				-> flushall						<清空全部数据库内容>
				-> exists name				<判断集合中是否包含'name'这个key是否存在，存在返回1>
				-> move name 1				<移动key为'name'的键值对到指定数据库1中，相当于剪切复制>
				-> expire name 10			<设置10s后，key为name的键值对就会过期，过期后就查询不到了>
					可以使用 ttl name 命令查询过期剩余时间
				-> type name 					<返回key所存储的value值类型>
				-> hlep @generic			<查看所有类型通用的命令，也可以修改@后面的类型，如：help @hash>
				------------
				-> append name " nb"	<对指定key的value后拼接字符串,key值不存在时就创建键值对。例：添加后(name:qlj nb)>
				-> strlen name ""			<通过key获取value字符串长度>

	2、redis是单线程的
		redis是基于内存操作的，CPU并不是redis的性能瓶颈，redis的瓶颈是根据机器的内存以及网络带宽所决定的。
		
		为什么单线程效率却很快？
			-> 首先，现在的CPU一般都是由多个核心组成，每个核心可以认为是一个独立的处理器，它们能够并行的处理任务。
			   所以，如果我们的CPU是多核的，但是程序是单线程的，那么执行程序时，这个线程在某一时刻只能在一个核心上
			   运行，而其他的核心就是空闲的(假设没有其他程序)。所以，为了提高CPU的使用率，我们可以创建多个线程，每
			   个线程处理任务的一部分(每个部分不依赖)，而每个核心执行一个线程，此时CPU的使用率将提高，程序运行速度
			   自然就会提高。
			-> 除此之外，假设我们的程序有A、B、C三个任务要执行，但是由于程序使用的是单线程，这些任务只能轮流执行，
			   A执行完毕后，其他任务再依次执行。如果A任务是一个比较耗时间的任务，此时B与C任务就要等待很长时间才能
			   执行。如果使用多线程，那么每个线程被分配到不同的核心上，可以并行的执行；若核心数量不够，CPU将采用时
			   间片轮转算法，轮流为每个线程分配时间片执行，这样后续任务也可以进行并发执行，无需等待之前的任务完成，
			   任务的响应速度变得更加均匀。
			<理解redis的单线程>
			-> redis中的单线程并不是指redis程序只会有一个线程。而是指redis处理客户端的数据请求，只会使用一个线程去
			   执行。但是实际上redis在执行其他操作时，可能会开启多个进程或线程，比如说持久化，就会fork出一个子进程，
			   然后子进程创建快照，完成持久化操作。
			<redis为什么是单线程>
			-> redis将数据存放在内存中，这就意味着，redis在操作数据时，不需要进行磁盘的IO，磁盘IO是一个比较耗时的操
			   作，所以对于需要磁盘IO的程序，我们就可以使用多线程，在某个线程进行IO操作的时候，CPU切换到当前程序的其
			   他线程执行，以此减少CPU的等待时间。而redis直接操作内存中的数据，所以使用多线程并不能有效的提升效率，
			   相反，使用多线程反而会因为需要进行线程切换人降低效率。
			   (当然在CPU切换线程的时候，有一个上下文切换时间，而这个上下文切换时间是非常耗费时间的)
			-> 除此之外，使用多线程的话，多个线程之间进行同步，保证线程的安全，也需要开销的。尤其是redis数据结构是一
			   些实现较为简单的集合结构，若使用多线程，将会频繁的发生线程冲突，线程的竞争频率较高，反倒会拖慢redis的
			   响应速度。
			<redis如何提高CPU的使用率>
			-> 前面说过，现在的CPU一般都有多个核心，每个核心可以单独执行。redis处理客户端请求使用单线程，那么自然而然，
			   无法将CPU的核心都占用，也就造成了资源的浪费。为了解决这一问题，我们可以在同一个服务器上开启多个redis程
			   序，每个redis程序使用不同的端口，相互独立，以此提高CPU的使用率，而这么多redis程序可以配置成主从节点，共
			   同为一个程序服务，也可以相互独立，服务于多个程序。
			总结：
				总的来说，redis使用单线程的原因就是：多线程并不能有效地提高redis的性能，相反可能还会降低性能，所以自然就
				会使用单线程。
	
	3、数据类型
		redis是一个key-value的数据库，key一般都是String类型，而value的类型较多。
			例如：
				-- 基本类型
					String：hello word
					Hash：{name:"qlj",age:23}
					List：[A -> B -> C -> C]
					Set：{A,B,C}
					SortedSet(Zset)：{A:1,B:2,C:3}
				-- 特殊类型
					GEO：{A:{120.3,30.5}}
					BitMap：0101101101
					HyperLog：0101101101
			
		-> 常用命令
			// 查看帮助信息
				help del			<查看del指令如何使用>
				help @generic	<查看通用的命令使用方式>
			
			// 查看符合模板的所有key，生产环境下不建议使用这种方式查询
				keys *				<后面可以进行模糊查询，*表示任意字符;?表示单个字符>
					
			// 删除一个或多个指定的key
				del key [key...] 			<后面可以跟多个keyname，返回的是删除的数量>			
			
			// 判断key是否存在
				exists key [key...]				<判断库中是否存在指定的key，存在返回1，可指定多个key>
			
			// 给一个key设置有效时间，有效时间到期就会自动删除
				expire key 时间(秒)				<例：expire name 10		// 可以使用  命令>
			
			// 查询指定key的剩余时间
				ttl key								<-2 表示过期，-1 表示永久有效，正数 表示剩余时间(秒)>
				
				
		-> String
			字符串类型，是redis中最简单的存储类型。
			value可以根据字符串的格式，再细分为3类：
				string：普通字符串	<例：a:hello>
				int：整数类型，可以做自增自减	<例：b:12>
				float：浮点类型，可以做自增自减	<例：c:12.1>
			注意：
				不管是哪种类型的String，底层都是字节数组形式存储，只是编码方式不同。字符串类型最大空间不超过512M
				
			-> 常用String命令
				// set：添加或修改已经存在的一个String类型的键值对
					例：set name qlj
				// get：根据key获取String类型的value
					例：get name
				// mset：批量添加多个String类型的键值对
					例：mset a 1 b 2.1 c 3
				// mget：根据多个key获取多个String类型的value
					例：mget a b c
					
				// incr：让一个整型的key自增1
					例：incr a		<2>
				// incrby：让一个整型的key自增并指定步长。
					例：incrby a 2		<3>			|			incrby a -1		<0>
				// incrbyfloat：让一个浮点类型的数字自增并指定步长
					例：incrbyfloat b 0.5			<2.6>
					
				// setnx：添加一个String类型的键值对，前提是这个key不存在，否则不执行
					例：setnx	name zmq			<由于库中存在name:qlj，此时出现相同的key，所以不执行>
				// setex：添加一个String类型的键值对，并且指定有效期
					例：setex name 10 zmq 			// 等同于：set name zmq ex 10
						<注意：expire命令是当键值存在的情况下才指定有效期，而setex命令在创建时进行指定有效期>
							
			-> redis没有mysql一样的表结构，如何区分不同业务类型的key？
				例：需要存储用户与商品的信息，有一个用户的id是1，刚好商品的id也是1。
				-> 层级结构
					redis中的key允许多个单词形成层级结构，多个单词之间使用':'隔开。
						格式：项目名:业务名:类型:id					<例：key1 = shop:user:1	key2 = shop:product:1>
					格式并不是固定的，可以根据具体业务结构制定。
					例：
						<注意两种':'不要混淆>
						shop:user:1 : {"id":1, "name":"qlj", "age":23}
						shop:product:1 : {"id":1, "name":"手机", "价格":4999}
							// 注意：如果在使用set存储时，使用String(json)字符串类型，需要给字符串添加单引号。如果是Hash类型，则直接添加
					
		-> Hash类型
			Hash类型也称散列，其value是一个无序字典(可以存储一个实际对象)，类似于Java中的HashMap结构。
				例：
					shop:user:1 : {"id":1, "name":"qlj", "age":23}
					key : {field:value,field:value,...}
			与value为String(json)类型的区别：
				String结构是将对象序列化为json字符串后存储，当需要修改对象某个字段时很不方便。
				Hash结构可以将对象中的每个字段独立存储，可以根据单个字段做crud
				也就是说：json格式的字符串实际就是字符串，它是一个整体，想要处理value中指定的字段时，就要做截取等等一系列操作才能将字段信息修改
				          而Hash类型的value，每个元素都是一个field:value，与json看似相同，实则是不同结构，Hash可以直接通过field(字段)处理value。
			
			Hash类型的数据结构：
				当value中的field-value较少时，使用ziplist压缩列表，当field-value较多时，则采用hashtable哈希表结构。
			
			-> 常用Hash命令
				// hset key field value：添加或修改hash类型key的field的值
					例：hset shop:user:1 id 1		|		hset shop:user:1 name qlj		|		hset shop:user:1 age 23
				// hget key field：获取一个hash类型key的field
					例：hset shop:user:1 name
				// hmset：批量添加多个hash类型key的field
					例：hmset shop:user:2 id 2 name zmq age 22
				// hmget：批量获取多个hash类型key的field
					例：hmget shop:user:2 id name age
				// hgetall：获取一个hash类型的key中的所有的field和value
					例：hgetall shop:user:2			<类似java的entrySet()方法>
				// hkeys：获取一个hash类型的key中的所有的field
					例：hkeys shop:user:2
				// hvals：获取一个hash类型的key中所有的value
					例：hvals shop:user:2
				// hincrby：让一个hash类型key的字段值自增并指定步长
					例：hincrby shop:user:2 age 2				<年龄字段的value值增加了2>
				// hsetnx：添加一个hash类型的key的field，前提是这个field不存在，否则不执行
					例：hsetnx shop:user:2 sex woman			<没有field为sex的字段，所以添加成功>
				
		-> List类型
			Redis中的List类型与LinkedList类似，可以看做是一个双向链表(实际更复杂quicklist)，既可以正向检索也可以反向检索。
			特征：
				有序：指存取顺序，并不是数据排序<索引号从0开始>
				元素可重复
				插入和删除快
				查询速度一般
			注意：List类型对两端的操作性能很高，通过索引下标的操作中间的元素节点性能会较差。
			
			-> QuickList数据结构
				List的数据结构实际是一种快速链表QuickList。
				// 数据量较少时
					首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，叫做压缩列表。
					压缩列表将所有元素紧挨着一起存储，分配的是一块连续的内存。
				// 数据量较多时
					数据量较多后就会改成quicklist结构。
					因为普通的链表需要附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针前驱、后继。
					quicklist结构是将多个ziplist使用双向链表结构串起来。这样既能满足快速插入删除性能，又不会占用较大空间。
					结构：
						ziplist1 <==> ziplist2 <==> ziplist3
			
			-> 常用List命令
				// lpush key element ...：向列表左侧(链头)插入一个或多个元素
					例：lpush stu:user:1 a b c
						<注意：实际上先执行将a插入链头，然后依次插入，所以最后一个c元素就在链头，它的索引序号为1>
				// lpop key：移除并返回列表左侧的第一个元素，没有则返回nil
					例：lpop stu:user:1 2				<2表示移除个数，移除左边两个元素，同时输出两个元素值>
					
				// rpush key element ...：向列表右侧(链尾)插入一个或多个元素
					例：rpush stu:user:1 4 5 6				<4先插到链尾，最终6是链尾>
				// rpop key：移除并返回列表右侧的第一个元素
					例：rpop stu:user:1 2		<2表示移除个数>
				
				// lindex key index：按照索引下标获得元素(从左到右)
					例：lindex stu:user:1 0
				// llen
					例：llen stu:user:1
					
				// lrange key star end：返回一段索引角标范围内的所有元素<闭区间>	(end 可以取-1,表示最后一个值)
					例：lrange shop:user:2 1 2		<第2个元素与第3个元素>
				// blpop和brpop：与lpop和rpop，只不过在没有元素时等待指定时间，而不是直接返回nil
					例：blpop stu:user:2 10
						<如果没有这个key程序就会阻塞，10s内如果有其他用户添加，在阻塞结束输出value，否则10s后退出>
			
			-> List可以模拟栈、队列、阻塞队列
								
		-> Set类型
			redis中的Set结构与java中的HashSet类似，所以其特性与HashSet也类似。
			特征：
				无序：指存取顺序无序，无索引值
				元素不可重复
				查找快
				支持交集、并集、差集等功能	
		
			-> Set常用命令
				// sadd key element：向set中添加一个或多个元素
				// srem key element：移除set中的指定元素
				// scard key：返回set中元素个数
				// sismember key element：判断一个元素是否存在于set中
				// smembers：获取set中的所有元素
				
				// sinter key1 key2：获取key1集合与key2集合的交集
				// sdiff key1 key2：获取key1中存在key2中没有的元素
				// sunion key1 key2：并集，不重复(重复只保留一个)
				
		-> SortedSet(ZSet)类型
				redis的SortedSet是一个可排序的set集合，与java中TreeSet功能类似，但是底层数据结构区别很大。SortedSet中的每个元素都带有一个
			score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加hash表。
			特征：
				可排序：指元素的排序
				元素不重复
				查询速度快
				
			SortedSet结构：
					SortedSet是Redis提供的一个非常特别的数据结构，一方面它等价于java的数据结构Map<String,Double>，可以给每个元素value赋予一个权重
				score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素列
				表。
				ZSet底层的两个数据结构：
					hash：hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。
					跳表(SkipList)：跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。
						
						-> 跳表<层次化链表>
							引言：
								对于数组来说：如果数据是有序的，搜索操作可以使用二分法搜索，时间复杂度为O(logn)，但是插入与删除时时间复杂度则需要O(n)。
								对于链表来说：即使链表是有序的，其搜索操作也无法使用二分法查找，只能按照顺序依次查询，时间复杂度O(n)，但插入与删除时间
								              复杂度是O(1)
								为了兼顾查找、插入、删除的效率，人们使用平衡二叉树。但无论是AVL树还是红黑树，其实结构都比较复杂。
								跳跃表的实现更为简单，且能够更好地支持范围查询。跳跃表中的元素是有序的，其查询、插入、删除的时间复杂度都是O(logn)。
							思想：
								跳跃表的基本思想是'分层'。
								跳跃表由多层链表堆叠而成，每一层都是一个链表，且处于不同层次的链表的跨度有所不同。处于最底层的链表就是普通的双链表，
								其跨度为1。从纵向来看，处于不同层次、具有相同关键值的节点堆叠而成，每个堆叠也是一个纵向的双链表。
								<特殊的插入：采用生长概率逐层减半策略。>
									生长概率逐层减半：
											首先必须先查询找到插入位置，找到位置后就是解决如何让纵向塔继续向上生长的问题。对于一个纵向‘塔’来说，第i层中的节
										点在第i+1层中继续生长出现的概率是1/2。跳跃表通过此策略保证空间复杂度为O(n)
							
				
			-> SortedSet常用命令
				// zadd key score element：添加一个或多个元素到sortedset，如果已经存在则更新score值
					例：zadd student 98 qlj 85 zmq 78 wzx 89 xyq
				// zrem key element：删除sortedset中的一个指定元素
				// zscore key element：获取sortedset中指定元素的score值
				// zrank key element：获取sortedset中指定元素的排名		<升序，zrevrank命令是降序排列。'rev'降序>
				// zcard key：获取sortedset中的元素个数
				// zcount key min max：统计score值在给定范围内所有元素的个数
				// zincrby key increment element：让sortedset中的指定元素自增、步长为指定的increment值
				// zrange key min max：按照score排序后，获取指定排名范围内的元素		<zrevrange降序>
				// zrangebyscore key min max：按照score排序后，获取指定排名范围内的元素
				// zdiff、zinter、zunion：求差集、交集、并集


-> redis配置文件redis.conf介绍
	配置文件中只支持bytes，不支持bit，大小写不敏感。
	includes部分。指配置文件可以包含其他文件的内容，使用include关键字实现。

	-> bind=127.0.0.1		// 只能接受本机的访问请求(想要远程连接要将其注释掉，且将protected-mode 改成no)
		不写的情况下，无限制接收任何ip地址的访问。<生产环境下要写服务器的地址，服务器需要远程访问，所以需要将其注释掉。>
		注意：
			如果开启了protected-mode(保护模式)，那么在没有设定bind ip且没有设密码的情况下，redis只允许接收本机的响应。
	-> port 6379			// 端口号	
	-> tcp-backlog 511			// 高并发环境下需要一个高backlog值来避免慢客户端连接问题。
	-> timeout 0				// 使用redis时，很长时间不使用时就会超时，0表示永不超时(秒)。
	-> daemonize yes			// redis是否为后台进程，设置为yes
	-> logfile ""					// 设置redis日志输出文件，默认为空
	-> databases 16				// redis默认有16个库
	-> SECURITY部分。redis默认没有设置密码<打开'requirepass foobared'的注释>
		// 或者使用命令进行设置redis密码
			config get requirepass
			config set requirepass "123456"
			auth 123456
	-> limits部分
		maxclients			// 设置redis同时可以连接的客户端数量，默认10000个
		maxmemory				// 最大内存容量。<建议必须设置，否则内存满了后服务器就会宕机，redis移除一部分数据>


-> redis的发布与订阅
	redis发布订阅是一种消息通讯模式，发送者(pub)发送消息，订阅者(sub)接收消息。
	redis客户端可以订阅任意数量的频道





-> redis的java客户端
	客户端网站：https://redis.io/clients				
	
	-> 常用客户端
		// Jedis
			以redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来连接使用
		// Lettuce
			Lettuce是基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式、管道模式。
		// Redisson
			Redisson是一个基于Redis实现的分布式、可伸缩的java数据结构集合。包含了诸如Map、Queue、Lock、Semaphore、AtomicLong等强大功能。
		<在Spring中使用Spring Data Redis，其底层兼容将了Jedis与Lettuce>
		
-> Jedis
	官网：https://github.com/redis/jedis
	
	使用步骤：
		1、引入依赖
			redis.clients 3.7.0
		2、
	





