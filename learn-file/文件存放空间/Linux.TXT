Linux
	-> 下载与安装
		先装虚拟机(VMWare)，再安装CentOS Linux系统。
		
		-> 安装虚拟机
			下载地址：<win10下载16版本的，否则会在安装的时候报错>
				https://customerconnect.vmware.com/en/downloads/info/slug/desktop_end_user_computing/vmware_workstation_pro/15_0
				<vm官网下载登录密码：Qlj_123456>
				
			安装步骤：
				1、在windows的BIOS中开启'虚拟化设备支持'。<win10默认开启了>
				2、直击双击安装程序，一直下一步即可
					<注意：取消勾选(启动时检查...；加入VMware客户体验...)>
				3、完成后点击许可证：
					<输入任意一个>
					ZF3R0-FHED2-M80TY-8QYGC-NPKYF
					YF390-0HF8P-M81RQ-2DXQE-M2UT6
					ZF71R-DMX85-08DQY-8YMNC-PPHV8
		
		-> 安装sentos7.9
			下载地址：
				https://mirrors.163.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso
		
			安装步骤：
				1、打开VMware，先新建一个虚拟机。
					典型 --> 稍后安装操作系统 --> Linux(L)<版本：Red Hat Enterprise Linux 7 64位>
					--> 给虚拟机系统起名(例：linuxOScentos7.6);修改位置：E:\linux\linux_Space <尽量放在磁盘容量大的盘符>
					--> 指定系统磁盘大小(最小20G，实际上并不是立即占用20g的空间，而是随着文件增多才会慢慢增加)；拆分多个文件
					--> 自定义硬件
						-> 内存：建议2G
						-> 处理器：取决于主机。建议2个cpu，只给2个内核，总共处理器内核是4个
							<查看主机的cpu处理器数：任务管理器-->资源管理器-->CPU-->看中间区域，有几个CPU使用率，就有几个cpu，本机只有
													'进程'与'服务'这两个CPU
							 查看内核数：看左侧CPU0~CPUn，内核总数 = n+1，每个cpu内核数 = n+1/2，本机总共有8个内核。
							>
						-> 网络适配器：一般情况下选择'NAT模式'
						-> 其他全部默认即可
					--> 点击关闭 --> 完成
					<注意：此时只是一个虚拟机的空壳，只是划好了区域，还没有操作系统>
					
				2、右击创建好的虚拟机 --> 点击设置 --> CD/DVD(SATA) --> 使用ISO映像文件(找到centos.iso安装包位置) --> 确定
				
				3、启动虚拟机 --> 双击黑色屏幕 --> 上下键选择'Install SentOS 7'<安装可能有点慢> --> 选择语言<简体中文>
					--> 注意弹出的‘安装信息摘要’框不要乱点，只需要点击'软件选择'(实际工作可以最小安装，不推荐)
						<默认是最小安装，有很多功能都不支持，比如：gcc、界面、jdk等>
						勾选：
							GNOME桌面：-> 兼容性程序库；传统X Windows系统兼容性；开发工具(gcc)
						点击左上角完成。不要急，等待一会,等到安装位置模块出现'已选择自动分区时再动'。
						-> 点击'安装位置'模块 -> 选择'我要配置分区' -> 点击完成
							<分区：
								boot(引导分区)：一般给1G就够了
								swap(交换分区)：一般与系统设置的内存大小一致即可，上面设置了2G内存
									作用：当实际内存被占用满了，此时有个应用或者程序想要启动占用内存，swap分区此时就会充当内存，让程序在swap
										  中运行，但是没有实际内存的效率高，所以只是作为备用<交换分区>。
								/(根分区)：剩余的都给根分区，50-1-2 = 47G，文件全部放在根分区。
							>
						-> 点击下面的'+' -> 挂载点选择'/boot'，期望容量'1G' -> 设备类型选择'标准分区'，文件系统选择'ext4'
						-> 再次点击'+' -> 挂载点'swap'，期望容量'2G' -> 设备类型选择'标准分区'，文件系统选择'swap'
						-> 再次点击'+' -> 挂载点'/'，期望容量'47G' -> 设备类型选择'标准分区'，文件系统选择'ext4'
						-> 完成 -> 接受更改
					--> KDUMP：实际开发中需要开启KDUMP，它可以在系统崩溃的时候查找原因并保存错误信息。但是在练习的时候不需要，所以取消勾选
					--> 网络和主机名：
						打开以太网 --> 修改主机名(例：linux01) -->应用 --> 完成
					--> SECURITY POLICY：安全策略，一般不应用，取消勾选
				
				4、点击'安装' --> 设置root密码<此处设置密码为：root> --> 创建用户(非root用户，其他用户) 用户名：qlj；密码：123456
				
				5、等待安装即可
				
				6、重启 --> 选择第一个'centos linux (版本) 7' --> 同意许可协议 --> 完成配置 --> centos默认使用非root用户登录，切换为root登录
					
				7、语言<汉语> --> 输入方式<汉语拼音> --> 隐私关闭 --> 在线账号跳过。
				
				8、桌面显示：右上角树状结构是网络；
				
				
		-> xftp与xshell下载安装
			地址：https://www.xshell.com/zh/free-for-home-school/
			xftp：
				系统间通过网络传输文件
			xshell：
				Linux终端
			-> 
				安装时不需要改什么，只需要修改安装位置，一直点下一步即可。
				
			-> xftp与xshell连接centos
				新建会话连接 --> 名称任意(192.168.10.128-LinuxOS) --> 主机(使用ifconfig查看系统ip) --> 协议'sftp' /ssh--> 端口号22
				--> 确定 --> 连接 --> 一次性接受 --> root用户名与密码 --> 连接成功
				<乱码解决方案：左上角'文件' --> 当前会话属性 --> 选项 --> 编码UTF-8>
				
				
				
		

	-> linux网络连接三种方式
		桥接模式：虚拟系统可以和外部系统通讯，但容易造成IP冲突。<同网段通讯>
		NAT模式：网络地址转换模式，虚拟系统可以和外部系统通讯，不造成IP冲突。
				<注意：实际使用本机代理通讯，但是只能往外通讯，外部不能访问虚拟系统>
		主机模式：独立的系统，不与外界通讯。

	-> 虚拟机克隆
		如果想要安装更多的linux系统，可以直接进行克隆。<搭建集群时>
			
		方式一：
			直接拷贝一份安装好的虚拟机文件
		方式二：
			使用vmware的克隆操作<注意：克隆时需要关闭linux系统>
				// 一般需要完整拷贝，拷贝完成后直接打开<用户密码一致>

	-> 虚拟机快照
			如果在使用虚拟机系统的时候<linux>，想要回到之前的某个状态，也可就是说可能有一些误操作造成系统异常，需要回到正常运行的状态，
		vmware提供了这样的功能，称作快照管理。
		例：
			安装好linux系统，先做一个快照A；然后创建文件夹再做一个快照B。
			此时想要从B状态回到A状态，就要使用快照管理。当然可以反复横跳。
	
	-> 虚拟机迁移和删除
			虚拟机安装完成后，其本质上就是一个文件。因此虚拟机系统迁移很方便，可以把安装好的虚拟系统文件夹整体拷贝或剪切到另外一个位置使用。
		删除时，先用vmware进行移除，再点击菜单->从磁盘中删除即可，或者直接手动删除虚拟系统对应的文件夹。
			
	-> 主机与虚拟机文件共享
		例：在主机D盘中存在一个文件，主机可以对其进行读写操作，虚拟机也可以对其进行读写操作。
		安装vmtools：
			<centos7已经自带了vmtools(桌面的光盘)，无需安装>
			// 进入虚拟机系统centos
			// 点击vm菜单的'install vmware tools'
			// centos会出现一个vm的安装包，xxx.tar.gz	<相当于windows压缩包>
			// 拷贝到/opt			打开终端 --> cd /opt [进入到opt目录] --> ls [查看目录内容] --> tar -zxvf xxx.tar.gz  [解压文件]
			// 使用解压命令tar，得到一个安装文件。	ls [查看目录] 
			// 进行该vm解压的目录，/opt目录下		cd 安装文件夹  [进入安装目录]
			// ./vmware-install.pl	[安装]		// 注意，要在安装目录内，且看一下安装文件名
			// 全部使用默认设置即可，就可以安装成功		一直回车<the VMware team 成功>
			// 注意：安装vmtools 需要有gcc	<gcc在安装系统的时候勾选了'安装通用开发工具'>		gcc -v [查看是否安装gcc]

		设置共享文件夹：
			// 先在主机D盘中新建一个文件夹myshare，存放一个hello.txt文件
			// 在vm虚拟机中，选中共享的虚拟系统，
				右击'设置'-->'选项'-->'共享文件夹'-->'总是启用'-->'添加'<找到myshare>-->下一步-->启用完成
			// 在linux系统中查看文件夹。'主文件夹'-->'其他位置'-->'计算机'-->'mnt'-->'hgfs'-->...
			// 找到hello文件打开进行修改测试。
		
		注意：在实际开发中，服务器是在远程的，并不与程序员主机在一块，此时如果共享文件，需要通过网络进行共享传输。
		
	-> Linux的目录结构
			linux的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录'/'，然后在此目录下再创建其他目录。
			<在linux世界里，一切皆文件！！！>
		
		-> bin	[常用]
			(/usr/bin、/usr/local/bin)
				是Binary的缩写，这个目录存放着最经常使用的命令。
			
		-> sbin
			(/usr/sbin、/usr/local/sbin)
				s就是super user的意思，这里存放的是系统管理员使用的系统管理程序。
				
		-> /home	[常用]
			存放普通用户的主目录，在linux中每个用户都有一个自己的目录，一般用户目录名是以用户的账号命名
		
		-> /root	[常用]
			该目录为系统管理员，也称超级权限者的用户主目录。
		
		-> /lib
			系统开机所需要最基本的动态连接共享库，其作用类似于windoes的DLL文件。几乎所有的应用程序都需要用到这些共享库。
		
		-> /lost+found
			这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。<一般被隐藏，在根目录下使用命令行'ls'查看>
		
		-> /etc	[常用]
			所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库的 my.conf
		
		-> /usr	[常用]
			这是一个非常重要的目录，用户的很多应用程序和文件安装默认都放在这个目录下，类似windows下的program files目录
		
		-> /boot	[常用]
			存放的是启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件
			
		-> /proc	[不能动]
			这个目录是一个虚拟目录，它是系统内存的映射，访问这个目录来访问系统信息
			
		-> /srv	[不能动]
			service缩写，该目录存放一些服务启动之后需要提取的数据。
			
		-> sys	[不能动]
			这是linux2.6内核的一个大的变化，该目录安装了2.6内核中新出现的一个文件系统sysfs
			
		-> /tmp
			这个目录是存放一些临时文件的
		
		-> /dev
			类似于windows的设备管理器，把所有的硬件用文件的形式存储
		
		-> /media	[常用]
			linux系统会自动识别一些设备，例如U盘、光驱等，当识别后，linux会把识别的设备挂载到这个目录
		
		-> /mnt	[常用]
			系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载到/mnt/下，然后进入该目录就可以查看内容了。<共享文件>
		
		-> /opt
			这是给主机额外安装软件所存放的目录。如安装oracle数据库就可以放在该目录下。默认为空。
		
		-> /usr/local	[常用]
			这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的源码
	
		-> /var	[常用]
			这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件
			
		-> /selinux	[sucurity-enhanced linux]
			SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。<启用后才可以看到>
			
	-> 远程登录Linux
		实际开发中，是多人协同访问服务器的。
		一般都是使用远程访问软件进行登录访问的。常用工具：xshell6(通过命令操作远程服务器)；xftp6(通过目录结构进行操作<可视化>，可传输文件)
		如何知道linux服务器的ip？
			右键打开终端 --> 输入'ifconfig' --> 此时可以查看服务器的ip	<虚拟机需要连网>
		
		测试是否可以访问到服务器?
			在主机内 --> cmd --> ping 服务器ip --> inet 192.168.10.128
	
		乱码要设置编码格式。
		
	-> vi和vim的基本介绍
			linux内置了vi文本编辑器
			vim具有程序编辑能力，可以看做是vi的增强版本，可以主动的一字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等
		方便编程的功能特别丰富。

		-> vi和vim的三种模式
			1、正常模式
					以vim打开一个文本，直接打开就进入一般模式(默认模式)。这个模式中，可以使用[上下左右]按键来移动鼠标，可以使用'删除字符'或
				'删除整行'来处理档案内容，也可以'复制、粘贴'来处理文件数据。
			
			2、插入模式
				接下i,I,o,O,a,A,r,R 等任何一个字母之后才会进入编辑模式，一般说按i即可，
			
			3、命令行模式
				这个模式可以输入相关指令，完成读取、存盘、替换、退出vim、显示行号的动作。
			
			-> 三种模式切换
				命令行模式 ---> 正常模式 ---> 编辑模式 ---> 正常模式 ---> 命令模式 ---> 命令行下
					vim Hello.java       i            esc             :				wq
				
				注意：在esc后，需要输入':'或者'/'进入命令行(此时没有保存退出)，只有输入wq才可以退出(wq只有保存退出的意思，并不是切换到命令行下)
				
				<:wq 保存退出		:q 退出		:q!	强制退出，不保存>(也可以将:换成/)
				
			-> vim常用编辑命令(以下都是对文档的操作)
				// 拷贝：(正常模式下)当前行'yy'，拷贝当前行向下5行'5yy'，并粘贴'p'
				// 删除：(正常模式下)当前行'dd'，删除当前行向下的5行'5dd'
				// 查找：在文件中查找某个单词('/关键字',回车查找；输入'n'就是查找下一个)
				// 行号：设置文件的行号，取消文件的行号(命令行下：':set nu' ; ':set nonu')
				// 编辑一个较大的文件，使用快捷键到该文档的最末行'G'和最首行'gg'
				// 在文件中输入hello，然后又撤销这个动作'u'
				// 编辑一个较大的文件，并将光标移动到20行 'shift+g'
				
				
	-> vim简单操作
		先以一个java文件为例，进行实操。<没有vim 可以执行 yum install vim>
			// 创建文件
				vim 文件名.后缀
				例：vim Hello.java	<直接回车就可以进入文件中>
			// 输入命令'i'，进入编辑模式
				此时可以输入文本java内容。
			// 输入完成后进行保存
				输入：'esc' --> ':wq'。 <回到命令行下>
		

	-> linux 启动与关闭
		注意：
			1、不管是关机与重启，都需要先运行'sync'，将内存中的数据写到磁盘。当然'shutdown/reboot/halt'都已经在关机前进行了sync。
			2、登录与注销
				登录时尽量少用root账号登录，root是系统管理员，权限最大，避免误操。可以用普通用户登录，然后'su -用户名'命令切换成root身份。
				注销时需要多用户存在才可以使用'logout'注销
				
			命令：
				shutdown -h now			// 立即关机
				shutdown -h 1				// 1分钟后关机
				shutdown -r now			// 重启计算机
				halt								// 关机，与上面一样
				reboot							// 重启
				sync								// 把内存数据同步到磁盘
				
	-> linux用户管理
			linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份
		进入系统。		
			-> 创建用户
				useradd 用户名
					例：useradd qlj 
				注意：当创建用户成功后，会自动的创建和用户同名的家目录。默认用户的家目录在/home/qlj。(登录后，文件目录自动在家目录下)
				<useradd -d /home/test zmq  此时创建的用户家目录是test >
			
			-> 设置密码
				passwd 用户名
					<回车后输入两次密码>
				注意：一定要写用户名，否则是修改当前用户的密码
			
			-> 删除用户
				注意：在root下删除。<自己不能删自己哦>
				// 只删除用户，不删除用户的家目录
					userdel 用户名
					
				// 用户与家目录都删除（慎重）
					userdel -r 用户名
			
			-> 用户信息
				id 用户名
			
			-> 切换用户
				su - 用户名
				注意：权限高的用户切换到权限低的用户，不需要密码；反之则需要。切换后可以用logout退回到切换前。
				
			-> 查看当前用户
				who am i
				注意：使用su切换用户后，再查看当前用户时，实际还是切换前的用户，这个命令只认初始登录的身份
				
			-> 用户组(权限分配)
				将用户分类/分组，组内是用户，每一组的权限不同，相同权限的用户为一组。	
				// 创建组
					groupadd 组名	
				// 删除组
					groupdel 组名
				// 用户进组
					-> 创建用户时进组
						useradd -g 用户组 用户名
							注意：如果创建用户时并没有指定组，系统默认创建一个组名为用户名的组，然后将用户放进改组
				// 查看用户在哪个组
					id 用户名
				// 修改用户的组
					usermod -g 用户组 用户名
					
	-> 服务运行级别
		说明：
			0:关机
			1:单用户<找回丢失密码>
			2:多用户状态没有网络服务
			3:多用户状态有网络服务
			4:系统未使用保留给用户
			5:图形界面<就是开机图形界面显示>
			6:系统重启
		切换：
			init [0123456] 			// 一般使用的是3和5
		
		linux开机流程：
			开机 --> BIOS --> /boot --> systemd进程1 --> 运行级别 --> 运行级别对应的服务


-> 其他常用命令
	// cat [-n] 文件名
		查看文件内容(只读)。	<-n 显示行号>
	
	// pwd
		显示当前用户所在的目录<绝对路径>。
		
	// clean
		清除命令行信息
		
	// ls [-a] [-l]
		查看目录内容；-a 可选 显示当前目录所有文件与目录，包括隐藏的；-l 可选 以列表的方式显示信息
		
	// cd [参数] 
		切换到指定目录
			例：
				'cd ~'/'cd :'			<回到家目录>
				'cd ..'						<返回当前目录的上一级目录>
				'cd /root/file'		<使用绝对路径>
				'cd file'					<如果当前在qlj目录下，想要去qlj目录的子目录file目录，使用相对路径>
				
	// mkdir [-p] 目录名
		创建目录。<-p 指创建多级目录，可以继续向下创建子目录>
	
	// rmdir [-rf] 目录名
		删除空目录。<添加rf后可以强制删除非空目录>
		
	// touch 文件名
		创建空文件。		<例：touch hello.txt>
		
	// cp [-r] source dest
		拷贝文件到指定目录。	<-r 递归复制整个文件夹>
			例：cp hello.txt aaa/				将hello文件拷贝到aaa目录下<相对路径>
				注意：如果指定目录下已经存在当前文件，提示输入y进行覆盖
	
	// rm [-r/-f] 文件名/目录名
		移除文件或目录。	<-r 递归复制整个文件夹；-f 强制删除不提示>
		
	// mv 
		-> mv 被移动文件 目标位置
			移动文件与目录。
		-> mv 旧名称 新名称
			重命名。
			
	// less 文件名
		分屏查看文件内容。<less在显示文件内容时不是将整个文件内容加载后显示的，而是根据显示需要加载的>
			分屏后：
				空白键				向下翻动
				page down			向下翻动
				page up				向上翻动
				q							离开less这个程序
	
	// more [选项] 文件名
		与cat命令类似，more是按页显示文本文件的内容，空白键向下翻动，b往回翻动。
		例：more -5 hello.txt		// 每页显示5行
				ls | more -5		// 显示当前目录下的所有文件和目录名称，并进行分页显示
	
	// echo [选项] [输出内容]
		输出内容到控制台。
			例：
				输出环境变量path：echo $PATH
				输出hello world到控制台：echo "hello world"
	
	// head [-n 数字] 文件名
		显示文件的开头部分内容。<默认前10行>
		例：
			head hello.txt				显示hello文件的前10行
			head -n 5 hello.txt		显示hello文件的前5行
	
	// tail [选项] 文件名
		输出文件中尾部的内容。<默认后10行>
	
	// >
		在控制台终端向文件中写入内容<覆盖原有内容>。
			例：
				echo "hello qlj" > /newfile/hello.txt		内容覆盖
				cat /newfile/hello2.txt > /newfile/hello.txt		文件内容覆盖
	
	// >>
		在控制台终端向文件中追加内容<追加>。<没有该文件会进行创建并添加>
			例：
				echo "hello qlj" >> /newfile/hello.txt
		
	// history
		查看执行过的历史命令。
		例：
			history
			history 10
		
	// 日期相关命令
		-> date								// 显示当前时间
		-> date "+%Y"					// 显示当前年份
		-> date "+Y-%m-%d"		// 按照'2022-9-22'格式显示当前日期
		-> date "+Y-%m-%d %H:%M:%S"		// 按照格式显示当前时间
		-> cal [选项]					// 显示当月日历，添加选项后例：cal 2022 显示2022年日历
	
	// find [搜索范围] [选项] 文件名
		从指定目录向下递归遍历其各个子目录，将满足条件的文件或目录显示出来。<例如windows下找某个文件一样>
			[选项]：
				-name：按照指定文件名查找模式查找文件
				-user：查找属于指定用户名所有文件
				-size：按照指定的文件大小查找文件		<+n 大于，-n 小于，n 等于。单位：k,M,G >
			
			例：
				find /home -name hello.txt				// 从指定home目录下进行搜索，按文件名查找模式进行查找文件
				find /home -name body							// 查找/home目录下，用户名为body的文件
				find / -size +200M 								// 查找整个系统大于200M的文件
				
	// locate 文件名 
		快速定位某个文件的文件路径。<第一次执行locate命令时，需要先执行updatedb指令><底层实际建立了一个数据库，通过数据库检索出路径>
		
	// while 命令
		查看某个指令的文件路径。
		
	// ps -ef 
		查看所有进程。<ps -ef | grep atd			查看进程中是否包含atd进程>
		
	// 压缩与解压
		gzip 用于压缩文件，gunzip	用于解压
		-> gzip 文件
			压缩文件，只能将文件压缩为'.gz'格式文件
			例：gzip /home/hello.txt
		-> gunzip 文件.gz
			解压文件。
		
		-> zip [-r] xxx.zip 文件/文件夹	[常用]
			压缩文件或者文件夹。<-r 递归压缩，即压缩目录>
			例：
				zip -r myhome.zip /home/			将home目录压缩为myhome.zip文件
		-> unzip [-d] xx.zip
			解压文件或文件夹。<-d：指定解压后文件的存放位置>
			例：	
				unzip -d /opt/tmp myhome.zip				将myhome.zip解压到/opt/tmp下
				
		-> tar [选项] xxx.tar.gz 打包内容
			打包，打包后的文件为xxx.tar.gz格式。打包内容可以是文件与目录
			[选项]：
				-c：产生.tar打包文件
				-v：显示详细信息			
				-f：指定压缩后的文件名
				-z：打包同时压缩
				-x：解包.tar文件
			例：
				tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt				// 将两个文件压缩为pc.tar.gz文件<压缩多个文件>
				tar -zcvf myhome.tar.gz /home/												// 将整个home目录打包为myhome.tar.gz
				tar -zxvf pc.tar.gz 																	// 解压pc.tar.gz文件。<注意当前目录不允许存在重复文件哦>
				tar -zxvf /home/myhome.tar.gz -C /opt/tmp2						// 将home目录下的myhome.tar.gz包，压缩到/opt/tmp2目录下
				

	
			
-> 组管理与权限管理
	在linux中每一个用户都必须属于一个组；每一个文件有三个概念<所有者，所在组，其他组>。
		所有者：一般哪个用户创建的文件，所有者就是这个用户
		所在组：文件属于一些组<也就是说，文件由哪个用户创建，则用户所在的组就是文件所在组>
		其他组：不是所在组就是其他组。
		
	所有者操作：
		-> 查看文件的所有者
			ls -ahl
			查看当前目录中所有文件/文件夹的所有者信息。
		
		-> 修改文件的所有者
			chown 用户名 文件名
			用户必须存在。
	
	所在组操作：
		-> 创建组<223行>
			groupadd 组名
		-> 用户进组
			useradd -g 组名 用户
		-> 查看文件/目录所在组
			ls -ahl
		-> 修改文件所在组
			chgrp 组名 文件名
	
	-> 权限
		-> 概念介绍：
			ls -l 		// 显示当前目录所有文件/目录权限及组信息	
				例：-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc
					权限|文件:硬连接数;目录:子目录数+子文件数|所有者|所在组|文件大小|修改日期|文件名
			'-rwxrw-r--'0~9位介绍：
				// 第0位：
						l是链接，相当于windows的快捷方式。
						d是目录，说明是一个文件夹
						c是字符设备文件，如：鼠标、键盘等
						b是块设备，比如硬盘
						-是普通文件，如txt、压缩包等
				// 第1~3位：
					确定所有者(该文件的所有者)拥有该文件的权限
				// 第4~6位：
					确定所属组(同用户组)拥有该文件的权限
				// 第7~9位
					其他用户拥有该文件的权限
			
			rwx作用：
				-> 对于文件来说：
					// [r]：可读权限，用于查看
					// [w]：可写权限，可以进行修改文件，但不代表可以删除文件，删除文件的前提是对该文件所在的目录有写权限，才能删除
					// [x]：可以被执行
				-> 对于目录来说：
					// [r]：可读权限，ls可以查看目录内容
					// [w]：可写权限，对目录内创建+删除+重命名目录
					// [x]：可以进入该目录<cd指令进入>
		
		-> 修改权限
			用过chmod指令，可以修改文件或目录的权限
			
			方式一：
				+、-、=变更权限
				u：所有者；q：所在组；o：其他组；a：所有人<代表u、q、o的总和>；	
					// chmod u=rwx,g=rx,o=x 文件/目录名
					// chmod o+w 文件/目录名
					// chmod a-x 文件/目录名
			方式二：
				通过数字变更权限<使用二进制理解>。
				r=4 w=2 x=1		rwx=4+2+1=7
					// chmod u=rwx,g=rx,o=x 文件/目录名	<==> chmod 751 文件/目录名
	
		
-> 定时任务调度
	任务调度：指系统在某个时间执行的特定的命令或程序
	任务调度分类：
		1、系统工作：有些任务必须周而复始的工作执行。如病毒扫描
		2、个别用户工作：个别用户可能希望执行某些程序。比如对mysql数据库的备份。
		
	单个执行一个批处理可执行文件：./my.sh
		
		1、反复执行任务
			crond命令：
				进行定时任务的设置。
					语法：crond [选项]				-e：编辑crontab定时任务		-l：查询crontab任务		-r：删除当前用户所有的crontab任务
				
				重启任务调度：service crond restart
				
				例：每分钟执行一次ls -l /etc/ > /tmp/to.txt命令
					// 首先打开编辑定时任务：crond [-e]
					// 执行：*/1 * * * * ls -l /etc/ > /tmp/to.txt
						<*/1 * * * *是cron表达式>
					注意：cron表达式具体可以查看stringboot中定时任务。
			
			例题：
				-> 每隔一分钟，就将当前的日期信息信息，追加到/tmp/mydate 文件中
					crond -e ---> * /1 * * * * date >> /tmp/mydate
					
				-> 每隔1分钟，将当前日期和日历都追加到/home/mycal
					此时需要写一个shell脚本，最后只需要定时执行脚本即可
					cd /home ---> vim my.sh ---> 编辑区中写：date >> /home/mycal   换行   cal >> date >> /home/mycal ---> 保存
					给这个文件添加'x'权限，可执行权限。< chmod u+x my.sh >
					定时执行shell脚本：crond -e	---->	* /1 * * * * /home/my.sh
				
				-> 每天凌晨2点将mysql数据库testdb，备份到文件中。
					crond -e ---> 0 2 * * * mysqldump -uroot -p123456 testdb >> /home/db.bak
		
		2、一次性定时执行
			at命令是一个一次性定时计划任务，at的守护线程atd会以后台模式运行，检查作业队列来运行。
			默认情况下，atd守护线程每60s检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业
			在使用at命令的时候，一个要保证atd进程的启动，可以使用相关指令来查看。
			<检测atd是否在运行：ps -ef | grep atd>
			
			语法：
				at [选项] [时间]
				ctrl + D 结束at命令的输入
				

----------------------------------
				
-> 磁盘分区原理
	
	-> windows分区
			windows系统主要是将磁盘分成几个分区<C盘、D盘等>，因此windows系统中是先有分区，再有目录文件夹，也就是把文件放入盘中。windows中的
		文件夹或者分区相当于一个容器中的容器<相当于俄罗斯套娃>。
			
	-> linux分区
			linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，linux中每个分区都是用来
		组成整个文件系统的一部分。
			linux中为每个分区对应一个设备文件名<任何物理设备，包括硬盘>，设备文件名不用手动分配，为自动分配。
			linux采用了一种'挂载(mount)'的处理方式，它的整个文件系统中包含了一整套文件和目录，且将一个分区和一个目录联系起来。这时要载入的
		一个分区将使它的存储空间在一个目录下获得。
			linux的挂载分为'自动'与'手动'。
				自动：系统安装创建的挂载点，后期使用会自动与硬盘分区建立联系
				手动：系统运行过程中，临时添加的U盘、移动硬盘不会被系统应用起来，需要手动创建一个文件目录并使其与该硬件进行联系挂载。
				<与新硬件形成联系挂载时，把挂载点目录内部的旧文件释放出去，然后再进行挂载操作>
			linux理论上的空目录，包括新建的目录都可以作为挂载点，但是/bin/、/lib/、/etc/目录除外，这些目录必须与根目录在同一分区，不能作为
		挂载点。<挂载点：进入分区访问数据的入口、标记>
			
		-> linux结构
			-> 从文件系统角度看
				根目录是最高目录，其他目录都在根目录下。
			-> 从硬盘角度看
				// 如果给/boot和/home单独进行分区，他们就会有自己的存储空间。也就是说，往/home里写数据，数据会写在/home目录所在分区的磁盘中。
				// 根目录下所有其他没有单独分区的目录，比如/etc等目录没有单独分区，所以，往/etc写文件的时候，会写在根目录所在分区的磁盘中。
	
	-> 查看所有设备挂载情况
		命令：
			lsblk	或者 lsblk -f			<-f会更加详细>
			
	-> 为linux增加硬盘
		步骤：虚拟机添加硬盘；分区；格式化；挂载；设置可以自动挂载。
		1、虚拟机添加硬盘
			右键虚拟机菜单中的linux系统 ---> 设置 ---> 点击'添加' ---> 硬盘 ---> 使用SCSI方式 ---> 设置添加磁盘大小 ---> 下一步至结束 
			---> reboot重启服务器
			<查看硬盘是否添加成功：lsblk>
		2、分区
			命令：fdisk /dev/sdb				<dev是设备文件，sdb就是添加的硬盘的文件名。也就是说，使用这块硬盘进行分配>
			步骤：
				fdisk /dev/sdb --> m --> n(添加新的分区) --> p(按照主分区分) --> 2(表示分两个区) --> 回车3次 --> w(写入并退出) 
				<查看分区信息：lsblk -f		(可以发现，此时硬盘sdb下面有两个分区sdb1与sdb2，但未对分区指定文件类型，uuid等其他分区为空)>
		3、格式化磁盘
			命令：mkfs -t ext4 /dev/sdb1				<ext4是分区类型。格式化sdb1分区>
		4、挂载
			将分区挂载到指定的目录。
			命令：mount 设备名称 挂载目录			<mount /dev/sdb1 /newfile>(目录必须存在)
			<此时使用lsblk -f 查看分区情况，mountpoint列的sdb1存在挂载点为/newfile目录>
			
			卸载：
				命令：umount /dev/sdb1 或者 /newfile			<此时sdb1与newfile目录的关联被删除，sdb1可以重新挂载到其他目录>
					<卸载时所在目录不能是newfile目录，退出目录后执行命令>
			注意：使用命令挂载分区的方式重启系统后就会失效<挂了个寂寞，但是文件依然存放在分区内>
		*5、永久挂载
			通过修改/etc/fstab实现挂载。<修改前可以添加一个快照，以防GG>
				修改步骤：
					vim /etc/fstab --> 复制一行挂载信息，修改uuid为待挂载分区的uuid，然后制定挂载点，最后将数子修改为'0 0'<不备份|不检查扇区>
					                   或者将uuid键值对写成带挂载分区的文件目录(例：/dev/sdb1)，然后写挂载点与数字
				  --> 保存退出(esc->:wq) --> 重启服务器
				
			添加完成后 执行命令：mount -a 即可生效。
	
	-> 磁盘常用指令
		// 查看磁盘使用情况
			df -h						<80%以上就要清一下>
		
		// 查询指定目录的磁盘使用情况
			du -h [目录]						<默认是当前目录>
			其他参数：
				-s：指定目录占用大小汇总
				-h：带计量单位
				-a：含文件
				--max-depth=1：子目录深度
				-c：列出明细的同时，总价汇总值
			例：du -hac --max-depth=1 /opt			查看/opt目录下的文件磁盘使用情况
	
-> 统计文件相关指令
	<以下以/opt目录为例>
	0、查看当前目录所有目录与文件
		命令：ls
	1、统计目录下文件的个数
		命令：ls -l /opt(显示opt目录下所有文件目录) ===> ls -l /opt | grep "^-"			// 表示将所有以“-”开头的文件查看出来
					===> ls -l /opt | grep "^-" | wc -l			// 统计个数
					
	2、统计目录下目录的个数
		命令：与上面步骤类似
				ls -l /opt | grep "^d" | wc -l			// 以“d”开头的就是目录
				
	3、统计目录下文件的个数，包括子文件夹中的文件
		命令：ls -lR /opt | grep "^-" | wc -l
	
	4、统计目录下目录的个数，包括子文件夹下的目录
		命令：ls -lR /opt | grep "^d" | wc -l
		
	5、以树状结构显示目录结构
		注意：先执行'tree /opt'，如果提示未找到指令，需要进行安装。
			安装指令：yum install tree
		命令：tree /opt
		
-------------------------------------		

-> linux 网络原理
	先去学学计算机网络原理吧。
	
	-> 了解
		-> DNS
			(Domain Name System)域名<网址>系统。让网络世界中成千上万的网址和服务器的IP地址进行一一对应，并可以进行查找与管理的一套机制。
			DNS服务器：让域名系统运行的服务器，专门用来记录每个网址对应的服务器IP地址的一种服务器。
			例：www.bilibili.com === 139.159.241.37
		-> 域名
							www    .    bilibili    .    com 
		       二级域名       一级域名      顶级域名
			相当于地区的规划：省级、市级、县级
			顶级域名：
				国际和地区顶级域名：cn、jp、...
				通用顶级域名：com、net、org、...
				新通用顶级域名：xyz、top、red、men、...
			
			.com下的：
				一级域名：
					一级域名就是在顶级域名下进行注册命名一个域，向运营商购买，不可重复。
					例：我买了一个'qlj.com'为一级域名
			.qlj下的：
				二级域名：
					自行设定一级域下的二级域名为'math'。
					此时整个二级域名就是：math.qlj.com。
					注意：为什么写的二级域名是math.qlj.com，因为math如果没有一级域与顶级域实际上是没有任何意义的。<就像快递地址必须从省开始>
			
			实际上不进行指定二级域名也可以确定ip地址，就像在浏览器中直接输入一级域名就可以访问网站。
			有了域名后，可以与任意的服务器进行绑定关联。
			总结：
				1、顶级域名是域名管理机构定义的，我们只能从现有的里面选择一个。
				2、我们买域名，其实就是选中某个顶级域名之后，在这个顶级域名下面自定义一个一级域名，表现出来就是你买到的就是一级域名和顶级域名
				   的组合。
				3、一级域名以下的二级域名，像'math.qlj.com'，甚至三级域名司机域名的取名和指向，是域名拥有者通过域名管理中的DNS解析设置来自行
				   设定的。
	
	
	-> 设置主机名和hosts映射
		1、设置主机名
			<在进行ping网络时，会使用ip地址进行网络连接测试的，配置主机名后可以通过主机名进行ping网络>
			-> 先查看主机名
				命令：hostname
			-> 修改主机名<在对应的文件中修改>
				命令：vim /etc/hostname --> 修改保存 -->reboot重启
		
		2、设置hosts映射
			<配置好主机名后，需要设置映射关系，让外部的主机知道这个虚拟机的主机名就是对应的对应的ip>
			-> windows访问linux
				在windows的'C:\Windows\System32\drivers\etc\hosts'文件中
					添加映射：192.168.200.130 主机名		<解释：192.168.200.130是linux系统主机的ip，主机名是linux的主机名>
			-> linux访问windows
				在/etc/hosts文件中添加：192.168.200.1 主机名		<分别是windows的ip与主机名(计算机名称)>
			
-----------------------------------

-> linux进程管理
	在linux中，每个执行的程序都是一个进程。每个进程都分配一个id号(pid,进程号)
		进程相关信息：
			USER：进程执行用户
			PID：进程识别号
			%CPU：占用cpu的百分比
			%MEM：占用实际物理内存的百分比
			VSZ：进程使用掉的虚拟内存量
			RSS：进程占用的固定内存量
			TTY：终端信息
			STAT：运行状态<s:休眠状态，r:运行状态>
			START：进程执行的开始时间
			TIME：此进程所用CPU时间
			COMMAND：正在执行的命令或进程名
	
	-> 进程管理命令
		1、ps [选项]
			用来查看目前系统中，有哪些正在执行，以及他们执行的状态。
			[选项]：
				-a：显示当前终端的所有进程信息；	-u：以用户的格式显示进程信息；	-x：显示后台进程运行参数
				-e：显示所有进程；	-f：全格式
			
			-> ps进阶
				// 查看具体某个线程是否执行
					ps -aux | grep xxx				<xxx表示进程名>
	
		2、终止<杀死>进程
			kill [选项] 进程号				// 通过进程号PID终止进程
			killall 进程名称					// 通过进程名称杀死进程，也支持通配符，当系统因负载过大而变得很慢时用到
			[选项]：
				-9：强迫进程立即终止
			
		3、查看进程树
			pstree [选项]
				[选项]：-p：显示进程pid;	-u：显示进程的所属用户
	
	-> 服务管理
		服务本质上是一个进程，但是运行在后台，通常都会监听某个端口，等待其他程序的请求，比如<mysql、防火墙等>，也成守护进程。
		service命令：
			service 服务名 [start|stop|restart|reload|status]
			// 注意：centos7后的版本不再使用service，而是使用'systemctl'。
		
		查看服务：
			// ls -l /etc/init.d			//查看服务量有限
			// setup
			
		服务自启指令：
			通过chkconfig命令可以给服务的各个运行级别设置自 启动/关闭。
			例：
				chkconfig --list [| grep xxx]					// 查看chkconfig管理的服务，运行级别的自启项<可以添加管道符过滤>。
				chkconfig --level 级别 服务名 on/off			// 修改某个服务在某个级别下是否自启动
					<chkconfig --level 5 network on>
			注意：修改后需要重启服务器。
			
		使用systemctl管理服务：
			上面管理服务的指令低版本可以使用，高版本使用systemctl。
			1、systemctl指令
				systemctl 服务名 [start|stop|restart|status]
				这种关闭启动服务，服务器重启就会失效，且受限于防火墙<先关闭防火墙服务>。
			
			2、查看服务
				
				
			3、服务自启指令
				systemctl list-unit-files [|grep 服务名]				// 查看服务开机自启状态，grep过滤<指定某个服务进行查看>
				systemctl enable 服务名 												// 设置服务开机自启
				systemctl disable 服务名												// 关闭服务开机自启
				systemctl is-enabled 服务名											// 查询服务是否自启
				注意：修改后重启服务器
			
		打开或者关闭指定端口：
				在真正的生产环境中，往往不允许关闭防火墙，但是将防火墙打开后，外部请求数据包就不能跟服务器监听端口通讯。这个时候就需要打开指定的
			端口，比如，80、22、8080等。
			-> firewall
				打开端口：
					firewall-cmd --permanent --add-port=端口号/协议
					例：firewall-cmd --permanent --add-port=8080/tcp
				关闭端口：
					firewall-cmd --permanent --remove-port=端口号/协议
				重新载入：
					firewall-cmd --reload
				查询端口是否开放：
					firewall-cmd --query-port=端口/协议
				查看已经开放的端口：
					firewall-cmd --zone=public --list-ports
		
		动态监控进程：
			类似于windows下cpu等服务运行的状态信息是实时更新的。而linux也有这种动态监控功能。
			-> top
				top与ps命令很相似，它们都用来显示正在执行的进程。top和ps最大的不同就是，top在执行一段时间可以更新正在运行的进程状态。
				命令：
					top [选项]
				[选项]：
					-d 秒数：指定top命令每隔几秒更新。默认是3s。
					-i：使top不显示任何闲置或者僵死的进程。
					-p：通过指定监控进程id来仅仅监控某个进程的状态。
					
			-> 交互操作
				在动态查看进程状态时需要知道哪些进程占用CPU或者内存过大。此时需要排序。
				步骤：首先使用top动态查看进程状态；然后输入指定字符就可以进行排序。
					P：以CPU使用率进行排序，此项是默认像
					M：以内存使用率排序
					N：以pid排序
					q：退出top
					u：指定某一进程动态查看状态<输入u后，才会让你输入进程名。可以监控某个用户在干啥>
					k：终止指定进程<例如想要将某个用户进程终止，防止它的危险操作>
					
		监控网络状态
			-> 查看网络情况			
				netstat [选项]
					-an 按一定顺序排列输出；-p 显示哪个进程在调用
		
--------------------------------------		
					
-> rpm包的管理
	rpm介绍：
			rpm用于互联网下载包的打包及安装工具，它包含在某些linux分发版中。它生成具有.RPM扩展名的文件。RPM类似于windows下的setup.exe，
		这一文件格式名称虽然打上了RedHat的标志，但是理念一致。
	
	相关指令：
		-> 查询已安装的rpm列表
			rpm -qa | grep xx					// 过滤查看指定的程序
				例：查看当前系统，是否安装了firefox。<rpm -qa | grep firefox>
			其它选项：
				-q：<加软件包名> 查询软件包是否安装。例：rpm -q firefox
				-qi：<加软件包名> 查询软件包信息
				-ql：<加软件包名> 查询软件包中的文件<可查看安装位置>
				-qf：<加文件全路径名>	查询文件所属的软件包		
		
		-> 安装rpm包
			rpm -ivh rpm包全路径名称
			参数：
				i：install 安装
				v：verbose 提示
				h：hash 进度条
			例：
				安装firefox软件：rpm -ivh 安装包位置
				注意：安装包位置需要在centos光盘中就有大量的rpm包，直接搜索找到firefox rpm包。
				
		-> 卸载rpm包
			rpm -e rpm包名称
				例：删除firefox软件包<rpm -e firefox>
				注意：如果其他软件包依赖于当前要卸载的软件包，卸载会出错。
			rpm -e --nodeps 软件包名
				强制卸载<但是依赖的软件包就会运行出错>
				
				
-> yum
		yum是一个shell前端软件管理器。基于rpm包管理，能够从指定的服务器自动下载rpm包并且进行安装，可以自动处理依赖性关系，并且一次安装所有
	依赖的软件包。<有点像maven中央仓库>
	
	基本指令:
		1、查询yum服务器是否有需要安装的软件
			yum list | grep xxx		
		
		2、下载并安装指定软件
			yum install xxx
				例：yum install firefox
			注意：yum可以自动处理依赖关。<如果下载安装的软件需要其他依赖软件，则会将依赖软件一起下载安装>

------------------------------

-> 实战来了
	1、安装配置jdk
		步骤：
			// mkdir /opt/jdk		创建一个文件夹
			// 通过传输软件<xftp>将安装包放在创建的目录下
			// cd /opt/jdk
			// 解压安装包：tar -zxvf jdk-8u261-linux-x64.tar.gz
			// mkdir /user/local/java		<类似于windows的Program Files>
			// mv /opt/jdk1.8.0_261 /user/local/java			移动解压的文件
			// 配置环境变量的配置文件：vim /etc/profile
			// 在profile文件末尾添加：export JAVA_HOME=/user/local/java/jdk1.8.0_261
			// 在profile文件末尾添加：export PATH=$JAVA_HOME/bin:$PATH					<查看系统的path信息：echo $PATH (输出内容到控制台)>
					注意：一定要在末尾添加$PATH，否则就会将之前的所有path路径直接覆盖掉
			// 配置好后执行命令：source /etc/profile 			<刷新path路径，让新的环境变量生效>
			// 执行：javac -version，java -version
				编写一个HelloWorld.java文件测试。
					
-------------------------------------------

-> shell脚本编程
	shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以使用shell来启动、挂起、停止程序。
	
	shell脚本格式要求：
		// 脚本以'#!/bin/bash'开头
		// 脚本需要有可执行权限
	
	第一个shell脚本：
		// 创建一个.sh文件，vim hello.sh
		// 脚本内容：
				#!/bin/bash
				echo "hello world!"
		// 加可执行权限：chmod u+x hello.sh
		// 执行hello.sh文件：
				方式一：./hello.sh 或者 绝对路径/hello.sh	<必须加可执行权限>
				方式二：也可以不加可执行权限执行shell脚本。
					chmod u-x hello.sh		// 取消可执行权限
					sh hello.sh						// 执行脚本

	shell变量
		分类：系统变量和用户自定义变量
		显示当前shell中的所有变量：set
			系统变量：$HOME、$PWD、$SHELL、$USER等。查看变量信息：echo $HOME
			自定义变量:
				定义变量：变量=值
				撤销变量：unset 变量
				声明静态变量：readonly 变量，注意：不能unset。		
				
				例：<在shell文件中写即可，执行脚本看上面执行方式>
						A=100												# 定义变量A
						echo $A											# 也可以：echo A=$A 或者 echo "A=$A"
						unset A											# 撤销变量A
						echo $A											# 输出为空
						readonly B=2								# 静态变量，只能被定义一次，且不能撤销
						echo $B											# 输出B
					注意：
						// 变量名称遵循字母、数字、下划线组成，且数字不能开头；
						// 等号两侧不能有空格
						// 变量名称一般使用大写
					将命令的返回值赋给变量：
						<将当前日期赋给变量A>
						// A=`date`	使用反引号<tab上面>，运行里面的命令，并把结果返回给变量A
						// A=$(date) 	等价于反引号
	
	设置环境变量
		语法：
			export 变量名=变量值		(将shell变量输出为环境变量/全局变量)
			source 配置文件					(刷新，让修改后的配置信息立即生效)
			echo $变量名						(查询环境变量的值)
		例：<配置java的环境变量>
			在profile文件内进行配置：vim /etc/profile
			在文件末尾添加：
				export JAVA_HOME=/user/local/java/jdk1.8.0_261
				export PATH=$JAVA_HOME/bin:$PATH
			保存后，刷新生效：source /etc/profile
			查看：echo $JAVA_HOME
			
	注释
		多行注释：:<<! 多行内容 !
	
	位置参数变量
		介绍：
			当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。<命令行中的参数相当于实参，脚本中的是形参>
			比如：./hello.sh 100 200，这个就是一个执行shell的命令行，可以在hello脚本中获取到参数信息。
		
		语法：
			$n <n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}>
			$* <这个变量代表命令行中的所有参数，$*把所有的参数看成一个整体>
			$@ <这个变量代表命令行中的所有参数，不过$@把每个参数区分对待>
			$# <命令行中所有参数的个数>
		例：
			<编写一个shell脚本position.sh，在脚本中获取到命令行的各个参数信息>
				// vim position.sh
				// 在shell脚本中输入：
						#!/bin/bash
						echo "参数1=$1，参数2=$2"
						echo "所有的参数=$*"
						echo "参数个数=$#"
				// 加权限：chmod u+x position.sh
				// 命令行中：./position.sh 100 200

	预定义变量
		就是在shell中定义好变量，可以直接在shell脚本中使用。
		
		语法：
			$$	<当前进程的进程号(PID)>
			$!	<后台运行的最后一个进程的进程号(PID)>
			$?	<最后一次执行的命令的返回状态，如果这个变量的值是0，证明上一个命令正确执行；
				   如果这个变量的值为非0(具体是哪个数，由命令来决定)，则证明上一个命令执行不正确>
	
	运算符
		语法：
			"$((运算式))" 或 "$[运算式]" 或者 expr m + n
			注意：
				// expr运算符间有空格<没有空格就会变成一个整体字符串>
				// expr m - n
				// expr \*，/，%		<乘、除、取余>
			例：
				<求在命令行中的两个实参的和>
					// vim var01.sh
					// 在shell脚本中输入：
							#!/bin/bash
							RES1=$[$1+$2] 
							echo "sum1=$RES1"
							
							RES2=$(($1+$2))
							echo "sum2=$RES2"
							
							RES3=expr $1 + $2
							echo "sum3=$RES3"
					// 加权限：chmod u+x var01.sh
					// 命令行中：./var01.sh 100 200

	条件判断表达式
		语法：
			[ condition ]			<注意condition前后存在空格> 	// 相当于if中的表达式 (true|false)
			# 非空返回true，可以使用$?验证(0为true，>1为false)
		
		例：
			[ hello ] 		// 返回true
			[  ]						// 返回false，<注意两个空格不能忽略>
			[ condition ] && echo "OK" || echo "notok"			// <&& 且，|| 或> 条件满足，执行后面的语句
			
		常用判断语句：
			// =		<字符串比较>
			// 整数比较	
				-lt	小于
				-le	小于等于
				-eq	等于
				-gt	大于
				-ge	大于等于
				-ne	不等于
			// 按照文件权限进行判断
				-r	有读的权限
				-w	有写的权限
				-x	有执行的权限
			// 按照文件类型进行判断
				-f	文件存在并且是一个常规文件
				-e	文件存在
				-d	文件存在且是一个目录
			例：
				<"ok"是否等于"ok"，不相等不作任何处理>
					if [ "ok" = "ok" ]
					then
						echo "相等"
					fi															// fi表示结束
					
				<23是否大于22>
					if [ 23 -gt 22 ]
					then
						echo "23大于22"
					fi
					
				</root/shcode/aaa.txt文件是否存在>
					if [ -f /root/shcode/aaa.txt ]
					then
						echo "存在"
					fi
	
	流程控制
		if语句
			语法1：
				if [ 表达式 ]
				then
					代码
				fi
			
			语法2：
				if [ 表达式 ]
				then
					代码
				elif [ 表达式 ]
				then
					代码
				fi			
	
		case语句
			语法：
				case $变量名 in
				"值1")
					程序1						// 当变量为1，则执行程序1
				;;								// 情况一结束的标志
				"值2")
					程序2
				;;
				...其他分支程序块...
				*)
					程序n						// 如果以上都不成立，则执行程序n
				;;
				esac
	
	循环控制
		for循环
			语法1：
				for 变量 in 值1 值2 值3...
				do
					循环体
				done
			
			语法2：
				for ((初始值;循环控制条件;变量变化))
				do
					循环体
				done
			例：
				<打印命令行输入的实参(可以使用$*和$@)>
					1、使用$*
						for i in $*							// $* 是把实际参数看做一个整体，所以for只循环一次，并且将全部参数直接一行输入
						do
							echo "num is $i"
						done
						
					2、使用$@
						for i in $*							// $@ 有几个实参，就会循环输出多少次，遍历输出
						do
							echo "num is $i"
						done
					
					3、使用语法2
						<求1~10累加和>
							SUM=0
							for ((i=1;i<=10;i++))					// i++ 也可以写成i=$[$i+1]	<一般当i++想要写在循环体中，才使用后面的写法>
							do
								SUM=$[$SUM+$i]
							done
							echo "sum=$SUM"
				
		while循环
			语法：
				while [ 条件表达式 ]			// 注意空格
				do
					循环体
				done
	
	read读取控制台输入
		<在执行shell程序时，程序请求输入一个参数值，程序阻塞，输入后才能继续执行>
		read(选项)(参数)
			选项：
				-p：指定读取值时的提示符
				-t：指定读取时等待的时间(秒)，如果没有指定的时间输入，就不再等待
			参数：
				变量：指定读取值的变量
		例：
			read -p "请输入一个数字NUM1=" NUM1			// 输入的值就会赋给NUM1
			echo "输入值NUM1=$NUM1"
	
	函数
		shell编程和其他编程一样，有系统提供的函数，也有自定义函数。
		系统函数：
			1、basename用法
				功能：返回完整路径最后/的部分，常用于获取文件名(包括文件后缀)
				语法：
					basename [pathname] [suffix]
					basename [string] [suffix]
						// basename函数会删除所有的前缀，包括最后的一个'/'字符，然后将字符串显示出来
						// [suffix]：如果suffix被指定了，basename会将pathname或string中的指定后缀suffix去掉，常用作去除文件后缀
				案例：
					<返回/home/aaa/test.txt 的文件名>
					直接当成命令在命令行中执行：
						basename /home/aaa/test.txt						// 输出：test.txt
						basename /home/aaa/test.txt .txt			// 输出：test
			2、dirname用法
				功能：返回完整路径最后/的前面的部分，常用于返回路径部分
				语法：
					dirname 文件绝对路径 
						// 从给定的包含绝对路径的文件名中去除文件名(非目录部分)，然后返回剩下的路径(目录部分)
					
		自定义函数：
			创建语法：
				[ function ] funname[()]
				{
					Action;
					[return int;]
				}
			
			调用语法：
				funname [实参]
				
			例：<计算两个参数的和>
				function getSum() {
					SUM=$[$n1+$n2]
					echo "sum=$SUM"
				}
				#请求输入
				read -p "请求输入参数n1=" n1
				read -p "请求输入参数n2=" n2
			
				#调用
				getSum $n1 $n2		
					
					
							
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	
	
	
	
	
	