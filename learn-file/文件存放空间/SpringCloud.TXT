-> 分布式架构需要考虑的问题
	1、服务拆分粒度<如何做业务拆分>？
	2、服务集群地址如何维护？
	3、服务之间如何通讯？
	4、服务健康状态如何感知？

-> 微服务架构特征
	1、单一职责：微服务拆分粒度更小，每个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发。
	2、面向服务：微服务对外暴露业务接口。
	3、自治：团队独立、技术独立、数据独立、部署独立。
	4、隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题。

-> 微服务技术栈
	1、Dubbo模式
		基于Dubbo的技术体系；服务接口采用Dubbo协议标准；服务调用采用Dubbo方式
	2、SpringCloud+Feign
		使用SpringClould技术栈；服务接口采用Restful风格；服务调用采用Feign方式
	3、SpringCloudAlibaba+Feign
		使用SpringClouldAlibaba技术栈；服务接口采用Restful风格；服务调用采用Feign
	4、SpringClouldAlibaba+Dubbo
		使用SpringClouldAlibaba技术栈；服务接口采用Dubbo协议标准；服务调用采用Dubbo方式
		
-> SpringCloud功能组件
	1、服务注册发现<Eureka、Nacos、Consul>
	2、服务远程调用<OpenFeign、Dubbo>
	3、服务链路监控<Zipkin、Sleuth>
	4、统一配置管理<SpringCloudConfig、Nacos>
	5、统一网关路由<SpringCloudGateway、Zuul>
	6、流控、降级、保护<Hystix、Sentinel>

-> SpringCloud与SpringBoot版本兼容关系
	<左：SpringCloud版本；右：SpringBoot版本>
	2020.0.x aka llford			2.4.x
	Hoxton						2.2.x、2.3.x(Starting with SR5)
	Greenwith					2.1.x
	Finchley					2.0.x
	Edgware						1.5.x
	Dalston						1.5.x





-> 服务拆分与远程调用
	-> 拆分
		1、不同微服务，不要重复开发相同业务
		2、微服务数据独立，不要访问其他微服务的数据库
		3、微服务可以将自己的业务暴露为接口，供其他微服务调用
	
	-> 远程调用
		<使用Spring框架提供的远程调用类RestTemplate>(类似于HttpClient功能)
		RestTemplate介绍：
				RestTemplate是由Spring框架提供的一个可用于应用中调用rest服务的类它简化了与http服务的通信方式，统一了RESTFul的标准，封装了http连接，
			我们只需要传入url及其返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更为优雅的调用RESTFul服务的方式。
				RestTemplate类的设计原则与许多其他Spring的模板类(例如JdbcTemplate)相同，为执行复杂任务提供了一种具有默认行为的简化方法。
				RestTemplate默认依赖JDK提供了http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如
			Apache HttpCompoent、Netty或OKHttp等其他Http libaray。
				考虑到了RestTemplate类是为了调用REST服务而设计的，因此它的主要方法与REST的基础紧密相连就不足为奇了，后者时HTTP协议的方法：HEAD、GET、
			POST、PUT、DELETE、OPTIONS例如，RestTemplate类具有headForHeaders()、getForObject()、putForObject()，put()和delete()等方法。
		
		使用RestTemplate远程调用：
			1、注册RestTemplate
				在消费者服务(Order服务)中注册RestTemplate。
				例：
					@MapperScan("cn.itcast.order.mapper")
					@SpringBootApplication
					public class OrderApplication {
						// 项目main方法
						public static void main(String[] args) {
							SpringApplication.run(OrderApplication.class, args);
						}
						// 注册RestTemplate
						@Bean
						public RestTemplate restTemplate(){
							return new RestTemplate();
						}
					}
			
			2、利用RestTemplate对服务提供者发送请求
				例：
					首先注入RestTemplate类：
					    @Autowired
						private RestTemplate restTemplate;
					在业务方法service中发送请求：
						// 1.查询订单
						Order order = orderMapper.findById(orderId);
						
						// 2.利用RestTemplate发起http请求，查询用户
						// 2.1.url路径
						String url = "http://localhost:8081/user/" + order.getUserId();
						// 2.2.发送http请求，实现远程调用
						User user = restTemplate.getForObject(url, User.class); // 参数2表示：请求响应返回值类型<json自动变成User>
						
						// 封装User对象到Order
						order.setUser(user);
						// 4.返回
						return order;
				注：
					重要的步骤是如何发送并响应信息。<步骤2>
					url地址就是当前服务对服务提供者发送请求的地址，参数order.getUserId()是请求参数，是一种restful风格的调用方式。
					getForObject()方法采用get请求类型进行发送。
					User.class表示响应数据类型。
			
	-> 服务提供者与消费者
		提供者：接收请求并响应消费者所需的服务称为提供者。<暴露接口>
		消费者：发送请求的服务称为消费者。<调用接口>
		
		注意：
			一个服务既可以是提供者又可以使消费者。<例：A 发送请求给 B，B 发送请求给 C。此时B既是提供者又是消费者>
	

-> Eureka注册中心
	以上远程调用出现的问题：
		url地址直接硬编码在服务中。
			在多环境的项目中，ip地址发生变化。在多服务项目中，一个业务可能有多个服务，端口号不同。
	
	eureka的作用：
		消费者如何获取服务提供者的信息？
			服务提供者启动时向eureka注册自己的信息；
			eureka保存这些信息；
			消费者根据服务名称向eureka拉去提供者信息。
		多个服务提供者，消费者该如何选择？
			服务消费者利用负载均衡算法，从服务列表中挑选一个。
		消费者如何感知服务提供者的健康状态？
			服务提供者每个30s向EurekaServer发送心跳请求，报告健康状态；
			eureka会更新记录服务列表信息，心跳不正常就会剔除；
			消费者就可以拉取到最新的信息。
	
	eureka架构角色：
		EurekaServer：服务端，注册中心
			记录服务信息；
			心跳监控
		EurekaClient：客户端
			Provider：服务提供者
				注册自己的信息到EurekaServer
				每个30s向EurekaServer发送心跳
			Consumer：服务消费者
				根据服务名称从EurekaServer拉取服务列表
				基于服务列表做负载均衡，选中一个微服务后发起远程调用
				
	-> 搭建EurekaServer并注册服务
		-> 创建一个eureka的微服务
			-> 在父工程下创建eureka服务；
				项目结构-->modules-->添加maven结构-->直接下一步(不勾选模板)-->选择父工程‘parent’，填写名称-->完成
			-> 引入eureka服务端依赖
				<dependencies>
					<!--eureka服务端-->
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
					</dependency>
				</dependencies>
			-> 添加项目启动类
				例：
					在Java目录下添加启动类：com.sg.eureka.EurekaApplication
						@EnableEurekaServer     // Eureka自动装配开关
						@SpringBootApplication
						public class EurekaApplication {
							public static void main(String[] args) {
								SpringApplication.run(EurekaApplication.class, args);
							}
						}
			-> 添加application.yml配置文件
				server:
					port: 10086 #服务端口
				spring:
					application:
						name: eurekaserver    #当前微服务eureka名称
				eureka:
					client:
						service-url:
							#eureka也是一个微服务，所以eureka将自己添加进eureka中
							defaultZone: http://127.0.0.1:10086/eureka  #多个eureka集群互相交流<当前是单机模式，此处应该是eureka集群地址>
			-> 通过启动类启动eureka服务。
				浏览器访问：http://localhost:10086/
			
			注意：
				eureka微服务自己也是需要eureka进行管理的，所以才需要配置yml中信息。
				访问页面中‘Instances currently registered with Eureka’是eureka中当前管理的服务。<此时只有eureka这一个服务>
		
		-> 将提供者与消费者服务注册到eureka中
			1、提供者服务配置：
				-> 导入eureka客户端依赖
					<!--eureka客户端依赖-->
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
					</dependency>
				-> 配置eureka服务地址与当前服务名称
					spring:
						application:
							name: userservice    #当前微服务user名称
					eureka:
						client:
							service-url:
								defaultZone: http://127.0.0.1:10086/eureka
								
			2、消费者服务配置
				-> 导入eureka客户端依赖
					<!--eureka客户端依赖-->
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
					</dependency>
				-> 配置eureka服务地址与当前服务名称
					spring:
						application:
							name: orderservice    #当前微服务order名称
					eureka:
						client:
							service-url:
								defaultZone: http://127.0.0.1:10086/eureka

			注意：yml文件中不允许有同名的配置名称。所以要进行同名称合并。
			
		-> 刷新/重启所有微服务。
			此时eureka页面中有三个服务。<注意：可能会存在浏览器缓存问题，刷新页面时先清理浏览器缓存>

	-> 如何实现多实例(服务)运行。
		也就是说，将提供者服务进行多次启动，实现多实例部署，每个实例的端口号必须不同，要修改端口号。
		<多实例就可以进行负载均衡>
		例：
			需要多个userservice服务实例
		步骤：
			在idea最底部工具栏中，打开'Services'栏。--> 找到UserApplication启动类，右键‘copy confguration...’ --> 修改名称<不重复即可>
			--> 在'Environment'栏的'VM options'(虚拟机选项)中添加“-Dserver.port=8082”(不冲突即可) --> 保存
			--> 此时在'Services'栏中多出一个未运行的服务，执行即可。
			《也可以在idea顶部'编辑配置'中copy服务。》
		
		注意：
			运行后，重新刷新eureka网页，可以发现‘USERSERVICE’服务的‘Status’中有两个实例。
	
	
	-> 消费者orderservice从注册中心拉取服务信息
		服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡。<上面的userservice就是一个服务名称两个实例>
		步骤：
			1、修改代码
				<在未使用注册中心eureka之前，我们使用了RestTemplate进行远程访问调用。此时我们采用eureka进行拉取服务信息>
				将
					String url = "http://localhost:8081/user/" + order.getUserId();
				修改为：
					String url = "http://userservice/user/" + order.getUserId();		// 采用微服务名称代替ip与端口号
			
			2、在消费者服务的启动类中的RestTemplate添加负载均衡注解。
				@Bean
				@LoadBalanced			// 负载均衡注解<作用：拦截RestTemplate发送的请求>
				public RestTemplate restTemplate(){
					return new RestTemplate();
				}
				
		测试：
			重新启动order服务，清空浏览器缓存，向order发送一个请求(这个请求到消费者服务器后，消费者服务器拉取提供者服务的信息)。
			注意：
				想要测试哪个实例被调用，可以清空idea中两个user提供者实例的执行日志，当前端执行成功，提供者实例就会执行，执行后就会产生日志。
		
****总结：
		1、搭建EurekaServer
			// 引入eureka-server依赖
			// 添加@EnableEurekaServer注解
			// 在application.yml中配置eureka地址
		2、服务注册
			// 引入eureka-client依赖
			// 在application.yml中配置eureka地址
		3、服务拉取/发现
			// 引入eureka-client依赖
			// 在application.yml中配置eureka地址
			// 给RestTemplate添加@LoadBalanced注解
			// 用服务提供者的服务名称远程调用
			
			
-> Ribbon负载均衡原理
	<学习文章：https://blog.csdn.net/tf835991342/article/details/122236383>
	小问题：我们知道，在消费者服务中采用的是服务提供者的服务名称代替了ip与端口号，那是否可以直接在浏览器执行这个被代替后的地址呢？
		修改前可以，修改后不可以。
		原因：服务名不是一个ip或地址，就算发给服务器也解析不了，何况浏览器解析不了也发不过去
	那么消费者服务代码修改后，它是如何将http://userservice/user/解析出来并选择一个提供者实例的？
		原因往下看。
	
	负载均衡流程：
		1、消费者服务发起请求http://userservice/user/1
		2、进入eureka-server中拉取userservice
		3、返回指定服务名称对应的实例列表：localhost:8081、localhost:8082
		4、轮询选择一个实例进行访问并响应
		<可查看PPT图例28>
	
	Ribbon在哪里进行拦截了？
		还记得我们在消费者服务中的启动类中配置了RestTemplate吗，我们在RestTemplate上添加了@LoadBalanced注解。
		该注解作用就是拦截RestTemplate发送的请求。
		
	基本流程：
		<以消费者服务中的http://userservice/user/1请求为例>
		1、LoadBalancerIntercepor拦截我们的RestTemplate请求http://userservice/user/1
		2、RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service
		3、DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表
		4、eureka返回列表，localhost:8081、localhost:8082
		5、IRule利用内置负载均衡规则<默认轮询>，从列表中选择一个，例如localhost:8081
		6、RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求
	
	轮询的负载均衡算法：
		rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标 ，每次服务重启动后rest接口计数从1开始。
	
	修改负载均衡规则：
		<常见：RoundRobinRule(轮询)、RandomRule(随机)、RetryRule(重试)...>(Rule接口有7个实现类)
		通过定义IRule实现可以修改负载均衡规则，有两种方式：
		1、在消费者服务中的启动类中定义一个新的IRule。
			// 随机负载均衡
			@Bean
			public IRule randomRule(){
				return new RandomRule();
			}
			注意：这种方式全局配置，只要是在该消费者服务中实现RestTemplate请求，都是这种负载均衡方式。
		2、	在配置文件消费者服务的.yml中配置。
			#修改IRule实现的负载均衡方式
			userservice:		#这个是指定的服务提供者名称
				ribbon:
					NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule  #'随机'负载均衡
			注意：这种配置方式，可以指定一个服务提供者进行配置。
	
	-> Ribbon负载均衡'饥饿加载'
		Ribbon默认采用的是懒加载，即第一次访问时才会创建LoadBalanceClient，请求时间很长。
		饥饿加载：
			在项目启动时就会创建，降低第一次访问的耗时。
		配置饥饿加载：
			<在消费者服务中的yml中进行配置>
			ribbon:
				eager-load:
					enabled: true     #开启饥饿加载
					clients: userservice    #指定对userservice这个服务饥饿加载
	
	
	
-> Nacos注册中心
	官网：https://nacos.io/zh-cn/		文档：https://nacos.io/zh-cn/docs/what-is-nacos.html
	下载：
		https://github.com/alibaba/nacos --> releases --> Tags --> 选择一个版本下载		<https://github.com/alibaba/nacos/tags>
	安装：
		直接解压即可。
	启动：
		在bin目录下的startup.cmd启动文件。
		管理员模式下在当前目录下，执行：startup.cmd -m standalone		// 单机启动<非集群模式>
	
	客户端：
		在cmd中启动成功后，nacos图标后有客户端网页链接地址，直接访问这个html即可。
		账号：nacos	密码：nacos
	
	-> 将服务注册到Nacos中
		1、在父工程的pom文件中添加spring-cloud-alibaba的管理依赖
			 <!--引入spring-cloud-alibaba管理依赖-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.2.5.RELEASE</version>
            </dependency>
			
		2、如果你是修改上面的项目，需要注释掉原有的eureka依赖<如果不是可以忽略该步骤>
		
		3、添加nacos的客户端依赖
			<!--nacos-client依赖-->
			<dependency>
				<groupId>com.alibaba.cloud</groupId>
				<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
				<version>2.2.5.RELEASE</version>
			</dependency>
		
		4、修改服务提供者与消费者的yml文件，添加nacos地址、微服务名称
			spring:
				application:
					name: userservice   #当前微服务的名称
				cloud:
					nacos:
						server-addr: localhost:8848  #nacos服务地址
		
		5、消费者服务中使用RestTemplate发送请求
			5.1、在消费者服务(Order服务)的启动类中注册RestTemplate。
				// 注册RestTemplate
				@Bean
				@LoadBalanced		// 负载均衡注解<作用：拦截RestTemplate发送的请求>
				public RestTemplate restTemplate(){
					return new RestTemplate();
				}
			5.2、利用RestTemplate发送远程请求<与eureka一样>
				String url = "http://userservice/user/" + order.getUserId();
				User user = restTemplate.getForObject(url, User.class);
			
		6、启动测试
			启动后，在nacos网页客户端中查看启动后的服务已经注册到注册中心。
	
	-> Nacos服务分级存储模型<集群>
		场景：
			对于一个服务可以部署多个实例，但不能将多个实例放在同一个地方，因此需要将多个实例部署到多个'机房'<容灾>。例：上海、西安、北京三个位置都部署
			了一个服务的实例，且一个位置有多个实例，每个位置构成了一个集群，多个位置有多个集群，共同协调。
		分级：
			服务(一级) --> 集群(二级) --> 实例(三级)
		
		-> 服务跨集群调用问题
			服务调用时尽可能优先选择本地集群的实例，跨集群调用延迟较高。本地集群不能调用时才去访问其他集群实例。
			
		-> 服务集群属性配置
			<目前userservice服务提供者有3个实例，将两个放在一个集群，剩余一个放在一个集群>
				1、修改application.yml配置信息。
					
					spring.cloud.nacos.discovery.cluster-name=xian		// 注意合并同名称<修改为yml格式>

					注意：配置完成后，如果想让user1与user2组成一个集群，则重启这两个实例。重新将'xian'集群名称修改为'weinan'，重启user3实例。
						  此时，集群'xian'中有两个实例，集群'weinan'中有一个实例。<配置好'weinan'名称后不要重启user1和user2>
		
				2、在Nacos网页监控页面查看集群变化。

			<目前orderservice服务消费者想要获取本地集群中的实例，所以也需要配置集群属性>
				1、配置orderservice服务实例所在的位置，按照userservice集群名称配置。
					例：消费者服务目前位于'xian'，所以就想调用userservice的'xian'集群实例。
						spring.cloud.nacos.discovery.cluster-name=xian    #当前消费者服务集群名称<与服务提供者某个集群名称一致>
					注意：
						我们知道消费者访问提供者时完全由Ribbon决定，选择实例也由IRule的负载均衡规则决定，所以此时order访问时还是进行'轮询'访问。
						目前并不能优先调用本地集群的提供者实例。
					
				2、设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务<优先随机调用同集群实例>
					userservice:		#这个是指定的服务提供者名称
						ribbon:
							NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule		#负载均衡规则(优先会寻找与自己同集群的服务)

				测试：
					将所有提供者服务实例开启，调用发现，消费者只会调用当前同集群的提供者服务，而且是随机调用。
					停止同集群下的提供者服务实例，发现第一次访问会找不到外地集群位置，再次访问就会成功访问。
			
		-> 按权重负载均衡
			<服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。>
			Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高
			-> 设置服务实例权重
				1、在Nacos网页控制台可以设置实例的权重值，首先选中实例后面的'编辑'按钮。
				2、将权重设置为0.1，测试可以发现8081被访问到的频率大大降低。
					注：权重值在[0,1]之间；设置为0后不会访问；同集群内的多个实例，权重越高被访问的频率越高
						默认情况下所有实例权重为1。<与其说是权重，不如说时调用实例的概率>
			使用场景：
				<平滑升级>
				在单实例项目中想要升级应用/程序时，必须下线后才能再次替换。而在多实例中，可以调节权重，权重调节为0后，用户就不会进行访问，此时可以
				进行程序升级，但不会影响用户访问其他实例。升级完成后，重新设置权重为0.1，此时放进来一少部分用户进行测试，成功后再调节权重完成升级。
	
	-> Nacos环境隔离-namespace
		<学习文章：https://www.kancloud.cn/qingshou/aaa1/2667182>
		结构：
			namespace 包含 group 包含 service/dataid
			
			// 一个namespace命名空间可以包含多个分组
			// 一个分组可以有多个子项目或者子模块的微服务
			// 每个子项目有自己的dataid，dataId命名规则带后缀，如：xxxx-dev.yaml、xxxx-pro.yaml，可以产生对某一个子项目部署环境配置文件加载隔离的效果。
		
		-> 创建并使用namespace
			微服务在没有明确指定配置的情况下， 默认使用的是Public命名空间。
			1、首先创建一个namespace
				在nacos网页控制台中创建namespace
				步骤：
					左侧栏'命名空间' --> 新建命名空间 --> 填写命名空间名与描述，id可以不填<默认会指定>(例：dev 开发环境) --> 确定
			
			2、使用创建的dev命名空间
				在服务中配置服务的namespace。
				<可以服务隔离配置与配置隔离配置>
				
					服务隔离配置：微服务属于不同的namespace，彼此之间不能远程调用
						spring.cloud.nacos.discovery.namespace=5279d5f1-eb9d-4ef4-abc1-86293aeb38a9		// 命名空间
					
					配置隔离配置：同一个namespace下的配置文件可以为该namespace下的多个子项目共享，跨namespace则无法实现配置文件共享
						spring.cloud.nacos.config.namespace=5279d5f1-eb9d-4ef4-abc1-86293aeb38a9
					下面只测试服务隔离配置配置隔离不使用。
			
			3、测试
				1、我们只在消费者服务配置了命名空间，看一下namespace的效果。
				2、重启消费者服务orderservice，刷新nacos网页控制台，可以看到服务列表中的dev模块下有orderservice服务。
				3、向消费者服务发送请求，测试是否可以执行成功<不同的namespace，彼此之间不能远程调用>
					此时出现500错误，由于namespace不同，会导致找不到userservice。
			注意:
				每个namespace都有唯一id
				服务配置namespace时要写id而不是名称
				不同namespace下的服务互相不可见
	
	-> Nacos与eureka的原理区别
		
		1、nacos注册中心感知服务健康状态时分为临时实例与非临时实例感知。
			临时：<服务向nacos发送心跳>服务被动/主动关闭后，nacos接收的心跳信息异常，直接下线对应服务
			非临时：<nacos主动获取服务心跳>如果发现服务异常关闭，处于不健康状态，则不会将服务删除下线，只会标记不健康。
			<非临时实例需要配置，且若配置后不删除这个实例一直在nacos中>
		   eureka只有临时实例。
		2、消费者服务会拉取nacos服务列表，并形成缓存，不会每次请求都要回去列表。
			服务列表缓存会定时进行更新。更新分为两种：
				① <pull>消费者定时拉取nacos中的服务列表。
				② <push>nacos中的服务发生变更，主动向消费者服务发送变更信息，及时更新缓存列表。
		   eureka只能做拉取操作。
		3、nacos集群默认采用AP模式，当集群中存在非临时实例时，采用CP模式。
		   eureka只有AP模式。

		非临时实例配置：
			在yml中配置
			spring.cloud.nacos.discovery.ephemeral=false	#设置非临时实例	
	
	
-> Nacos统一配置管理
	-> 基本介绍
		在单体应用中，配置管理可能不是什么大的事情，通常会以配置文件的方式。常见的方法比如将配置通过打包脚本打入应用包中，或者直接放到运行应用的
		服务器的特定目录下，或者存储到数据库中。这种方式在传统的单体应用中简单有效，但是也会有些比较棘手的问题。
		比如：
			// 配置变化频繁时，需要频繁的打包部署应用。
			// 不同环境的配置需要分开管理（比如测试环境与生产环境）。
			// 而在分布式微服务架构中，服务数量剧增，如果还是手动去实现配置信息的修改或数据的迁移等，效率是很低的，而且手动操作配置也极有可能出现
			   错误的情况。
		复杂的业务对应大量的配置项，对集群部署的应用配置进行修改时需要修改每个节点上的应用配置，在这种背景下，中心化的配置服务即配置中心应运而生。
		配置中心：
			<
			 配置中心就是一种统一管理各种应用配置的基础服务组件，配置中心可以把业务开发者从复杂以及繁琐的配置中解脱出来，只需专注于业务代码本身，从
			 而能够显著提升开发以及运维效率。同时将配置和发布包解藕也进一步提升发布的成功率，并为运维的细力度管控、应急处理等提供强有力的支持。
			>

		在微服务架构中，微服务的统一配置管理一般有以下需求：
			// 集中管理配置：一个使用微服务架构的应用系统可能会包括成千上万个微服务，因此集中管理配置是非常有必要的。
			// 不同环境不同配置：例如，数据源配置在不同的环境（开发、测试、预发布、生产等）中是不同的。
			// 运行期间可动态调整：例如，可根据各个微服务的负载情况，动态调整数据源连接池大小或熔断阈值，并且在调整配置时不重启微服务。
			// 配置修改后自动更新：如配置内容发生变化，微服务能够自动更新配置。

		综上所述，对于微服务架构而言，一个通用的配置管理机制必不可少，常见做法是使用配置服务器管理配置。

	-> 实现配置管理
		1、在nacos中创建配置文件
			步骤：
				1、在nacos网页客户端中，打开左侧'配置管理'栏 --> '配置列表'
				2、点击右边'+'，进行配置。
					// data id：一般使用'服务名称-运行环境.yaml'名称，例：userservice-dev.yaml
					// group：分组，默认即可
					// 描述：随意。例：userservice的开发环境配置文件。
					// 配置格式：yaml
					// 配置内容：
						<注意：配置内容是将来用于热更新的，所以配置内容是一些经常进行修改的配置信息。例：数据库地址一般不需要热更新>
						例：配置日期格式
							pattern:
								dateformat: yyyy-MM-dd HH:mm:ss		// 日期格式配置 <以后可以更改此处实现日期的热更新>

		2、服务读取创建的配置文件
			问题：spring是在什么时候读取项目中的application.yml文件的？
			答：项目启动 ---> 读取项目配置文件application.yml ---> 创建Spring容器 ---> 加载Bean对象
			
			nacos配置文件读取流程：
				项目启动 ---> 先读取nacos配置文件 ---> 读取项目配置文件application.yml ---> 创建Spring容器 ---> 加载Bean对象
			
			思考：既然优先读取的是nacos配置文件，而nacos的地址却在application.yml中配置着，想要读取到外部的nacos配置文件，肯定是要先知道nacos地址。
			
			解决方案：将nacos地址单独取出来，放到读取nacos配置文件之前。
				spring中提供了一个bootstrap.yml文件，这个配置文件spring会优先读取。
			
			所以：
				项目读取nacos配置文件流程：
					项目启动 ---> 读取bootstrap.yml文件 ---> 读取nacos配置文件 ---> 读取项目配置文件application.yml ---> 创建Spring容器 ---> 加载Bean
			
			-> 步骤：
				1、引入nacos配置管理客户端依赖<在userservice服务中>
			        <!--nacos配置管理客户端依赖-->
					<dependency>
						<groupId>com.alibaba.cloud</groupId>
						<artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
						<version>2.2.5.RELEASE</version>
					</dependency>
				
				2、在userservice中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml
					spring:
					  application:
						name: userservice   #服务名称
					  profiles:
						active: dev   #开发环境
					  cloud:
						nacos:
						  server-addr: localhost:8848  #nacos服务地址
						  config:
							file-extension: yaml  #文件后缀名
				
				3、删除application.yml中重复的配置信息
					例：当前微服务的名称；nacos服务地址。<因为bootstrap中已经存在>
				
				4、在controller中写一个接口，用于测试nacos配置文件是否能够使用。
					4.1、注入nacos配置文件的配置信息，使用dateformat接收
					    @Value("${pattern.dateformat}")
						private String dateformat;
					4.2、编写接口 (配置信息实际是'yyyy-MM-dd HH:mm:ss')
						@GetMapping("/now")
						public String now() {
							return new SimpleDateFormat(dateformat).format(new Date());
						}
				
				5、重启服务，测试是否正常响应
					浏览器输入：http://localhost:8081/user/now
			




