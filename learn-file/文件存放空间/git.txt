git
	它是一个免费的、分布式的版本控制工具，或是一个强调了速度快的源代码管理工具。
	
	->版本控制
		<版本迭代>
		1、实现跨区域多人协同开发
		2、追踪和记载一个或多个文件的历史记录
		3、组织和保护源代码与文档
		4、统计工作量
		5、并行开发、提高开发效率
		6、追踪记录整个软件的开发过程
		7、减轻开发人员的负担，节省时间，同时降低人为错误
		

	->集中式版本控制工具
		特点：
			版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，
		再把自己的活推送给中央服务器。
			本地是没有版本库的修改记录的，所以集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可
		如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。

	->分布式版本控制工具
		特点：
			分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作时，就不需要联网了，因为版本库就在你自己的电脑上。
		问题：
			既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？
		答：
			比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
			既然是多人协作，我们肯定是需要指定一个人的电脑作为总仓库，所以人从他的电脑上提交更新，拉取别人的提交，这样才能保证他的仓库保留了所有人的改动。
			这个人其实就充当了集中式中的服务器仓库的角色。
			所以我们通常说的分布式管理系统的服务器就是其实就是找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到
			自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。
			
	->git工作机制
		
		工作区：代码/文件存放在本地电脑的磁盘目录位置。
				<git add> 添加到暂存区
		暂存区：暂存区可以理解为临时（或者临时）存放内容，不是作为正式提交的版本，但是它已经被git管理，暂存区中的内容可以很容易被git正式提交，
				同时它如果不合适可以进行回退操作。一般存放在"git目录"下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。
				<git commit> 提交到本地库
		本地库：工作区有个隐藏目录.git，它就是Git的本地版本库，每次提交会生成一个版本。
				
				<push>
		远程库：代码托管中心，例如：(互联网上)码云、github	；(局域网上)GitLab
		
	
	-> git下载
		https://npm.taobao.org/mirrors/git-for-windows/
		选择最下面版本<例：v2.36.0.windows.1/>，点进去选择后选择最新版<Git-2.36.0-64-bit.exe>
	-> git安装教程
		https://zhuanlan.zhihu.com/p/443527549
	
	-> git常用命令
		<首次安装必须设置签名>
		git config --global user.name 用户名		// 设置用户签名<例：qlj>
		
		git config --global user.email 邮箱			// 设置用户签名<例：1966910355@qq.com>
		《如何查看签名配置成功？位置：C:\Users\DELL\.gitconfig文件中查看》
		
		git init 				// 初始化本地库<创建一个空Git仓库或重新初始化一个现有仓库(可以先创建一个本地目录，在目录中打开git命令行，成功后生成.git)>
		
		git status				// 显示工作目录与暂存区的状态
				<On branch master：当前本地库在master分支；
				 No commits yet：目前没有任何提交；
				 nothing to commit：没有需要提交的文件<为创建文件时>
				 
				 Untracked files：发现一个未被追踪的文件，红色文件名：只是存在于工作区
				 
				 Changes to be committed：绿色文件名：已添加到暂存区
				 
				 nothing to commit, working tree clean：提交到本地库后的状态信息
				>
		------------------------------------
			-> 新增文件
				vim hello.txt		<回车进入文本编辑>
				按'i'进入编辑模式；按'esc'退出编辑模式<命令模式>。
				命令模式下：'yy'复制，'p'粘贴，':wq'保存
				
			ll 			// 查看当前目录下的文件
			cat hello.txt		// 查看文档内容
			tail -n 1 hello.txt		// 查看文档最后一行
			
			-> 修改文件
				vim hello.txt -----> i 进入编辑模式 -----> 修改文本 ------> esc 退出编辑模式 ------> :wq 保存
				
				修改后提交到暂存库与本地库。		1 file changed, 2 insertions(+), 2 deletions(-)		一个文件修改，2行新增，2行删除<表示修改>
				
				git reflog查看版本信息。 发现有两个版本。	但是指针指向修改后的版本，所以cat查看时，只查看修改后的版本。
		------------------------------------
			
		git add 文件名.后缀				// 将文件从工作区添加到暂存区		
		
		git rm --cached 文件名.后缀		// 删除暂存区的文件，工作区中的文件未删除		<git status 变成红色名>
		
		git commit -m			// 将暂存区文件提交到本地库。-m 表示版本日志信息<不写-m，也会有，一般手写>
			例：git commit -m "first commit" hello.txt
			
		git reflog			// 查看引用日志信息
		
		git log				// 查看详细日志信息<包括：完整版版本号，指针指向，提交人，提交日期> 'q' 退出
		
		------------------------------------
			-> 版本穿梭
				git reset --hard 版本号
					从当前版本退到之前的版本。
					1、先查看版本信息 git reflog，复制想要穿梭的版本号
					2、输入：git reset --hard 版本号
					3、此时指针已经发生偏移，cat文件时查看的是穿梭后的版本
					
				<查看当前指针只想位置：.git\refs\heads\master>

		ctrl + L		// 快速清屏
		
		<注意：git在版本穿梭时，只是master指针在移动指向不同版本号，head一直指向master>


-> 分支
	
		在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离
	开来，开发自己分支的时候，不会影响主线分支的运行。可以理解为分支就是副本，一个分支就是单独的副本。
		<分支底层其实也是指针的引用>
	
	优点：
		同时并行推进多个功能开发，提高开发效率。
		各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。
	
	-> 分支操作
		
			git branch 分支名								// 创建分支
			git branch -v									// 查看分支
			git checkout 分支名								// 切换分支
			git merge 分支名								// 将指定的分支合并到当前分支上 <一般是在master主分支上合并其他分支>
			git branch -d 分支名							// 使用-d删除分支时，被删除的分支必须与上游分支合并才能删除<-D不会检查是否合并>
			
	-> 冲突合并
		合并分支时，两个分支在同一个文件有两套完全不同的修改。Git无法替我们决定使用哪一个，必须人为干预新代码内容。
		例：
			在master分支上修改hello.txt文件中最后一行，并提交到本地库中。
			切换<checkout>到其他分支，发现当前版本文件未修改<不同分支>，依然修改文件最后一行，并提交到本地库中。
			切换回master主分支，使用合并命令进行合并，此时会报错，git不知道选择保留哪个支的内容。<新的命令行表示(master|MERGING)正在合并中>
			查看本地状态，可以看到没有合并成功。
		-> 手动合并
			// 手动vim打开文件，可以看到两次修改的内容都可以看到，进入编辑模式，将需要保留的部分保留，不需要的直接删除，保存即可。
			// 将合并后的文件从工作区添加到暂存区，然后再提交到本地库中
				注意：提交的时候不要带文件名，会报错<git commit -m "merge test">
			
		<合并成功后，只有master分支的文件合并成功了，切换到分支后被合并的分支并不会发生变化，依然是只有自己修改的发生变化了>
			
				
-> git团队协作<代码托管中心>
	详解查看图解。
	
-> github创建远程库
	步骤：
		登录--->右上角‘+’--->添加远程库名称<一般是项目名>--->选择分类<公共：读权限公开>--->直接creating repository
	
	-> 创建远程库别名
		目的:远程库链接较长，不容易记忆，创建别名后方便拉取。
		
		-> 命令
			git remote -v 					// 查看当前多有远程地址别名
			git remote add 别名 远程地址			// 创建别名<最好与库名一致>
		
	-> 本地库推送到远程库(push)
			git push 别名 分支			// 将本地库中的具体某一分支推送到远程库(也可以是实际地址)<例：git push project01 master>
				// 推送时较慢且需要登录账户
		
	-> 拉取到本地库(pull)
			git pull 别名 分支			// 将远程库的项目拉取到本地库(相当于更新)
				// 拉取时会自动提交本地库<status正常>
	
	-> 克隆
		git clone github项目地址
		
			首先建一个文件夹，将远程库的项目克隆到当前文件夹下
		注意：
			在文件夹内打开git bash here，再执行命令。<克隆不需要登陆账号(公共库)>
			clone实际上的操作：1、拉取代码；2、初始化本地仓库(init)；3、创建别名(别名：origin)

-> github团队协作
	-> 团队内
		选择邀请合作者
			注意：其他本地clone到项目后，做了修改，修改后想要推送到我的github上，此时需要写入权限(加入到团队中)。
			
			邀请需要推送的github用户：
					进入自己的远程项目库---> 点击Settings---> Manage access---> Invite a collaborator(邀请<输入账号>)---> 复制Pending Invite(邀请函)
					---> 将地址发送给受邀人员---> 受邀人员访问改地址---> 点击Accept invition(同意邀请)
			// 同意邀请后才可以推送代码
			
	-> 跨团队协作
		此处介绍将别人的代码叉一份到自己的远程库。
		
		1、叉一份别人的项目步骤：	
			登录自己的github ---> 找到指定的项目 ---> 点击右上角Fork ---> 此时就已经将项目叉到自己的远程库了
			
		2、将项目修改后推送给项目主人：
			点击上面Pull request ---> New pull request ---> create pull request ---> 此时相当于发邮件<编写主题与内容> ---> create pull request
			
		3、此时项目主人刷新一下自己的项目就可以看到我发的项目推送请求。<当然，可以发送回复(中门对狙)>
		
		4、项目主人认为项目修改的很好(审核)，可以进行合并。
			操作：点击请求页的Merge pull request ---> 点击确认合并<完毕>
			
-> SSH免密登录
	作用：在本地库推送(push)文件时不需要登录账户也可以推送。
	
	添加SSH免密公钥
	步骤：
		1、先在电脑的家目录下查看是否存在.ssh文件(/用户/dell/.ssh)，没有的话到第2步
		2、在dell家目录下打开命令行，执行：ssh-keygen -t rsa -C 账号名		<多敲几次回车至结束>例：ssh-keygen -t rsa -C "1966910355@q.com"
		3、此时dell目录中就存在.ssh目录，<可直接查看的是公钥>，也可以在命令行中查看具体信息。<cd.ssh 跳转到目录，直接cat查看>
		4、将公钥复制到github中。
			位置：点击右上角图像下拉---> Settings---> SSH and GPG key---> new ssh key---> 添加一个名称(随意)，将公钥粘贴到key中---> add ssh key
		5、此时再次推送文件时就可以免密推送。<id_rsa.pub 公钥名称>
		
		
-> IDEA集成git
	1、配置git忽略文件
		<与项目实际功能无关的文件>
		作用：在java项目中会存在一些idea配置文件或其他没有任何作用的文件，此时不需要将这些文件推送到git中，所以要设置git忽略文件(iml/.idea文件)
		-> 如何忽略
			方法一：<一般不用>
				创建一个忽略规则文件xxx.ignore(建议：git.ignore)
				位置：<原则上哪里都可以>为了方便让.../.gitconfig文件引用，建议放在用户家目录下(C:/用户/dell/....)。
				git.ignore文件格式：
					*.class				// 所有的.calss文件忽略掉
					*.log					// 所有的log日志忽略
					*.jar
					*.war			
				# 注释
				
				引用git.ignore：
					在.gitconfig文件(dell目录内)中添加：
									[core]
										excludesfile = C:\Users\dell\git.ignore				#注意斜线
			
			方法二：
				// 在idea的plugins插件中心搜索'.ignore'，下载插件，重启idea
				// 在项目目录上右击新建'New'(例：项目Project01项目目录下) --> 选择'ignore file' --> 选择'.gitignore file'
				   --> 在ignore file generator窗体中，勾选'Example user template'(示例用户模板) --> generate
			
	2、idea定位git程序
		Setting ---> Version Control ---> git
			-> path to git executable：git安装目录<注意：定位到git.exe程序>		tset：查看版本信息
	
	3、git管理idea项目
		<管理到项目时项目根目录下存在.git目录>(当然你可以用命令行进行管理)
		
		如何在idea创建本地库(init)?
			点击工具栏 VCS ---> import into version cotrol(导入到控制版本) ---> create git repository(默认选中的就是项目的根目录) ---> ok
		此时可以看到在项目根目录中存在.git文件。<idea中pom文件变红了，相当于使用命令行时没有将文件添加到暂存区(当前目录在工作区)>
		
		如何在idea中将文件添加到暂存区？
			选中目标文件 ---> 右击 ---> git ---> add		<文件名变绿了>
			// 当然，新建class文件时，idea会自动提示是否添加到暂存区
			// 也可以之间右击项目根目录，直接将所有文件添加到暂存区，添加时会提示(是否强制添加忽略的文件)，此时一定要点击‘取消’，不能add
		
		如何将文件提交到本地库？
			与添加到暂存区操作一样，选择‘commit directory’ ---> 打开提交框后在commit message中写提交信息(例：first commit)
			// 提交成功后文件名会变成黑色
		
	4、idea切换提交版本(版本穿梭)
		注意:
			idea并不是使用reset命令进行版本切换的，reset方式是直接把head以及master一起拉回到那个版本，并且会丢失目标版本之后的内容，
		虽然可以使用reflog找到后面的版本，但是这种方式会有丢失数据的风险。
			idea使用的是 git checkout -b <branch-name> <commit>，这种方式是临时在目标版本新建一个分支，然后切到分支中去查看，再切回来的时候，
		它使用 git branch -d <branch-name> 的方式，再把临时创建的那个仅供回看的目的分支给删除掉。
		
		-> 多提交几个版本做测试用
			直接修改代码，修改后文件名变成蓝色，表示被追踪过，但被修改了，需要重新add and commit
				<注意：提交新的版本时，idea会显示上一个版本内容以及版本号，与当前版本作对比>
		
		-> 如何查看版本信息
			在idea左下角的'version control'/'git'中，选择'log'栏。此时可以查看所有版本信息。
				(黄色标签是头指针，绿色标签是分支指针)
		
		如何穿梭回初始版本？
			在'log'栏中的各个版本中，右键一个版本，选择‘checkout revision '版本号'’。(此时分支指针会移动到切换的版本)
			
	5、idea创建、切换、合并分支
		-> 创建步骤：
			右键项目名 ---> git ---> repository ---> branches ---> new branche ---> 输入分支名称(勾选checkout branche 切换到new的分支)
			或者：idea右下角点击‘git master’(当前分支) ---> new branche
		
		-> 切换分支
			按照创建的步骤，当弹出 git branches框后，可以看到local branches中所有分支信息，直接点击'checkout'即可切换。
			
		-> 合并分支
			<正常合并：只修改一个分支的信息>
				将其他分支合并到master分支。
					按照创建的步骤，当弹出 git branches框后，可以看到local branches中所有分支信息，直接点击"被合并分支"的'merge into current'即可合并。
				合并成功后，在master分支下可以看到代码已经合并。
			
			<冲突合并>
				在合并过程中，点击'merge into current'后会弹出一个冲突(conflicts)框 ----> 点击'merge'
				此时idea弹出三栏代码：
							左边是一个修改过的分支(master)，右边也有一个修改过的分支(hot-fix)，中间是即将合并为的代码。(我愿称作左右为难)
					点击提示箭头即可添加进行合并。
	
	6、idea集成github
		-> idea绑定登录github
			位置：在settings中的github中配置。<没有github，可以在plugins中下载>
			如何进行配置？
					点击右侧"+"，添加用户(可添加多个) ---> 输入要添加的github账户与密码 ---> 登录
				<注意：使用账号与密码登录时，由于网络限制可以会一直登陆不上>
			如何使用口令登录？
				点击登录框的右上角‘user token’ ---> 在github中获取口令 ---> 点击登录
					口令获取：
						github --> settings --> developer settings --> personal access... --> generate new token --> 填写名称 --> 勾选所有权限
						--> generate token --> 复制口令 --> 粘贴到idea中
		
		-> idea将本地库项目分享到github
			注意：正常情况下需要先创建远程库，然后才能推送项目。但是，idea有github插件，不需要创建远程库。
			步骤：
				VCS --> import into version cotrol(导入到版本控制) --> share project on github --> 弹出设置框
				--> 设置远程库名及公共与私有<项目名>、别名<库名>、默认信息不需要填 --> 成功
		
		-> 推送(push)、拉取(pull)、克隆(clone)
			// 推送(push)
					注意：先修改代码，然后直接提交本地库。
				法一：右键项目名 --> git --> repository --> push
				法二：VCS --> git --> push
				弹出push框：默认选中一个别名，且默认使用https链接进行push。
				
				如何使用ssh协议push?
					复制github中的ssh链接 --> 点击push框的默认别名 --> define remote --> 定义名称(ssh-git)以及粘贴url --> 成功后就可以选择ssh链接push
		
			// 拉取(pull)
					可以先在github上直接修改代码 --> 填写版本信息，提交。
				注意：
						push是将本地库的项目推送到远程库，如果本地库代码根远程库代码版本不一致，push操作会被拒绝。也就是说，要想成功push，一定要保证
					本地库的版本要比远程库的版本高。<因此，在改本地代码前，一定要检查远程库跟本地库代码的区别，如果本地库代码已经版本落后，切记一定
					要先pull拉取远程库的代码，将本地先更新之后，再修改、提交、推送>
						当然，如果在拉取的时候发现本地库的代码已经改动过，会自动进行合并代码，但是如果出现代码合并冲突，依然需要手动解决冲突。
				
				拉取步骤：
					VCS --> git --> pull
					弹出pull设置框 --> 选择ssh链接(注意勾选分支‘ssh-git/master’) --> pull
				
			// 克隆(clone)
					删掉本地原有项目，在存储位置里面删除。<直接下载也行>
				步骤：
					重新打开idea --> 打开时在初始页面(选择打开项目的页面) --> 点击‘get from version control’ --> 选择git、粘贴ssh链接、项目位置
					--> 克隆
			
		
		
		
	
	
	
	
	
			
